<!DOCTYPE html>
<html>
<head>

<title>Operating Systems Design and Implementation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../js/jquery-1.6.4.min.js"></script>

<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shCore.css">
<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shThemeRDark.css">
<script type="text/javascript" src="../../js/sh/scripts/shCore.js"></script>
<script type="text/javascript" src="../../js/sh/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../js/main.js"></script>
<script type="text/javascript" src="../../js/ASCIIMathML.js"></script>

<link rel="Stylesheet" type="text/css" href="../../style.css">
<link rel="Stylesheet" type="text/css" href="../../css/main.css">

</head>
<body>
	<div class="hidden">
		<input id="root_path" type="text" value="../../">
	</div>
	<div id="body-wrapper">
		<div id="container">
			<div id="top">
				<div id="page-title">
					<a href="../../index.html">烂笔头</a>
				</div>
				<ul id="top-nav">
				</ul>
			</div>
			<div id="middle">
				

<div class="toc">
<ul>
<li><a href="#toc_1">Operating Systems Design and Implementation</a>
<ul>
<li><a href="#toc_1.1">什么是操作系统</a>
<ul>
<li><a href="#toc_1.1.1">操作系统作为虚拟机</a>
<li><a href="#toc_1.1.2">操作系统作为资源管理器</a>
</ul>
<li><a href="#toc_1.2">操作系统发展历史</a>
<ul>
<li><a href="#toc_1.2.1">第一代计算机(1945 ~ 1955):真空管和插板</a>
<li><a href="#toc_1.2.2">第二代计算机(1955 ~ 1965):晶体管和批处理系统</a>
<li><a href="#toc_1.2.3">第三代计算机(1965 ~ 1980):集成电路芯片与多道程序</a>
<li><a href="#toc_1.2.4">第四代计算机(1980 ~ NOW):个人计算机</a>
</ul>
<li><a href="#toc_1.3">操作系统基本概念</a>
<ul>
<li><a href="#toc_1.3.1">进程Process</a>
<li><a href="#toc_1.3.2">文件File</a>
<li><a href="#toc_1.3.3">进程Process</a>
<li><a href="#toc_1.3.4">命令解释器Shell</a>
</ul>
<li><a href="#toc_1.4">系统调用System Calls</a>
<ul>
<li><a href="#toc_1.4.1">进程管理的系统调用Process management</a>
<li><a href="#toc_1.4.2">信号管理的系统调用System Calls for Signaling</a>
</ul>
</ul>
</ul>
</div>

<h1 id="toc_1">Operating Systems Design and Implementation</h1>

<ul>
<li>
软件分为系统软件和应用软件

<ul>
<li>
系统软件管理系统及应用程序

<li>
应用软件执行用户最终所需要的功能

<li>
最基本的系统软件就是操作系统

<li>
它控制计算机的所有的资源并提供开发应用程序的基础

</ul>
<li>
virtual machine

<ul>
<li>
在裸机上加载一层软件来管理整个系统，为用户提供一套更容易理解与编程的接口

<li>
这个接口叫virtual machine

<li>
层软件号操作系统

</ul>
<li>
微程序microprogram

<ul>
<li>
一层原始软件

<li>
控制设备并向上一层提供一套更清晰的清晰的接口

<li>
它实际上是一个解释器：也取得机器语言的指令，执行相应的指令

</ul>
<li>
精简指令集计算机（Reduced Instruction Set Computer, RISC)

<ul>
<li>
没有微程序层

</ul>
<li>
操作系统专指运行在内核态(kernel mode)或管态(supervisor mode)下的程序。

<ul>
<li>
它受硬件保护而免遭用户篡改

<li>
命令解释器 编译器 编辑器运行在用户态(user mode), 它们是应用程序。

</ul>
</ul>
  
<h2 id="toc_1.1">什么是操作系统</h2>
<h3 id="toc_1.1.1">操作系统作为虚拟机</h3>
<ul>
<li>
操作系统为用户提供一台等价的扩展计算机，或叫虚拟机，它比低层硬件更容易编程。

</ul>

<h3 id="toc_1.1.2">操作系统作为资源管理器</h3>
<ul>
<li>
跟踪资源的使用状况、满足资源请求、提高资源利用率，及协调各程序和用户对资源的使用冲突。

</ul>

<h2 id="toc_1.2">操作系统发展历史</h2>
<ul>
<li>
第一台数字计算机，英国数学家Charles Babbage设计，纯机械式，无操作系统

<li>
第一个程序员：Ada Lovelace,诗人拜伦的女儿。

</ul>

<h3 id="toc_1.2.1">第一代计算机(1945 ~ 1955):真空管和插板</h3>
<ul>
<li>
每一台都专门设计，使用机器语言，没有编程语言，没有操作系统

</ul>
 
<h3 id="toc_1.2.2">第二代计算机(1955 ~ 1965):晶体管和批处理系统</h3>
<ul>
<li>
卡片，磁带，批处理（读入一队作业，顺序执行），负责读入作业并输出结果的特殊程序就是操作系统的前身

</ul>
 
<h3 id="toc_1.2.3">第三代计算机(1965 ~ 1980):集成电路芯片与多道程序</h3>
<ul>
<li>
当一个作业在等待io时，cpu就会空闲下来，很浪费

<li>
<strong>多道程序(multiprogramming):</strong>

<ol>
<li>
将内存划分为几部分，每一部分存放一个作业

<li>
当一个作业在等待io时，另一个作业可以使用cpu

</ol>
<li>
<strong>spooling:</strong>

<ol>
<li>
Simultaneous Peripheral Operation On Line, 联机即时外设操作

<li>
可以很快的将卡片上的作业读入磁盘。

</ol>
<li>
<strong>分时系统(timesharing):</strong>

<ol>
<li>
多道程序的变种

<li>
每一个用户有一个终端

<li>
cpu轮流为它们服务

<li>
可以为用户提供交互式服务

<li>
每个用户感觉自己拥有一个完整的计算机

<li>
cpu空闲时可以执行后台大作业

</ol>
<li>
UNIX

<li>
POSIX

</ul>

<h3 id="toc_1.2.4">第四代计算机(1980 ~ NOW):个人计算机</h3>
<ul>
<li>
网络操作系统

<li>
分布式操作系统

</ul>


<h2 id="toc_1.3">操作系统基本概念</h2>

<p>
<strong>系统调用</strong>
</p>
<ul>
<li>
由操作系统提供的操作系统与用户程序之间交互的 <strong>扩展指令集</strong>

<li>
两大类

<li>
与进程相关的 <strong>系统调用</strong>

<li>
与文件相关的 <strong>系统调用</strong>

</ul>

<h3 id="toc_1.3.1">进程Process</h3>
<p>
<strong>进程Process</strong>
</p>
<ul>
<li>
一个进程本质上是一个程序的 <strong>执行</strong>

</ul>
<p>
<strong>地址空间address space</strong>
</p>
<ul>
<li>
每个进程拥有自己的address space: 0 ~ 最大值

<li>
address sapce 中有： 可执行程序， 程序数据， 程序的堆栈

</ul>
<p>
<strong>进程还包括：一组寄存器register 程序计数器program counter 指针stack pointer  其他硬件寄存器hardware register</strong>
<strong>进程表 process tabel:</strong>
</p>
<ul>
<li>
除address space之外的进程所有的信息都保存在一张表中

<li>
每一进程对应表中的一项

<li>
process table 是一个结构数组或链表

</ul>
<p>
<strong>一个进程包括:</strong>
</p>
<ul>
<li>
address space, 又叫内核映像core image

<li>
process table中的一项

</ul>
<p>
<strong>进程间通信</strong>
</p>

<p>
<strong>中断和信号</strong>
</p>

<p>
<strong>一个挂起的进程，需要再运行，则需要把进程暂停前的所有信息都保存下来</strong>
</p>


<h3 id="toc_1.3.2">文件File</h3>

<h3 id="toc_1.3.3">进程Process</h3>
<ul>
<li>
File

<li>
Directory

<li>
9位保护码

<li>
Mount

<li>
设备文件（Special File)

<ul>
<li>
块设备文件Block special files

<li>
字符设备文件Character special files

</ul>
<li>
piple

</ul>

<h3 id="toc_1.3.4">命令解释器Shell</h3>
<ul>
<li>
它不是操作系统的一部分

<li>
这是终端用户与操作系统之间的一个重要接口

</ul>

<h2 id="toc_1.4">系统调用System Calls</h2>
<ul>
<li>
POSIX标准

</ul>

<p>
<strong>进程管理Process Management:</strong>
</p>
<pre  class="brush:c">
    //创建一个child process
    pid = fork();
    
    //等待一个child process结束
    pid = waitpid (pid, &amp;statloc, opts)
    
    //老版本的waitpid
    s = waitpid (&amp;status)
    
    //替换一个进程的内核映象
    s = execve (name, argv, envp)
    
    //结束进程执行返回一个状态码
    exit (status)
    
    //设置数据段大小
    size = brk (addr)
    
    //返回调用者进程号
    pid = getpid ()
    
    //返回调用者组标识号
    pid = getpgrp ()
    
    //创建一个会话并返回其组标识号
    pid = setsid ()
    
    //用于调试
    l = ptrace (req, pid, addr, data)
</pre>
    
<p>
<strong>信号Signal</strong>
</p>
<pre  class="brush:c">
    //定义对信号的处理工作
    s = sigaction (sig, &amp;act, &amp;oldact)
    
    //从信号返回
    s = sigreturn (&amp;context)
    
    //检查或修改信号掩码mask
    s = sigprocmask (how, &amp;set, &amp;old)
    
    //获得阻塞信息集合
    s = sigpending (set)
    
    //替换信号掩码并挂起进程
    s = sigsuspend (sigmask)
    
    //给进程发送一个信号
    s = kill (pid, sig)
    
    //设置时间闹钟
    residual = alarm (seconds)
    
    //挂起调用进程直到下一个信号
    s = pause ()   
</pre>

<p>
<strong>文件管理File Management:</strong>
</p>
<pre  class="brush:c">
    //创建一个新文件
    fd = creat (name, mode)
    
    // 创建普通、设备文件或目录i节点
    fd = mknod (name, mode, addr)
    
    //打开一个文件进行只读或读写操作
    fd = open (file, how, ...)
    
    //关闭一个已打开的文件
    s = close (fd)
    
    //从文件读数据到缓冲区
    n = read (fd, buffer, nbytes)
    
    //从缓冲区将数据写入文件
    n = write (fd, buffer, nbytes)
    
    //移动文件指针
    pos = lseek (fd, offset, whence)
    
    //获取文件状态信息
    s = stat (name, &amp;buf)
    
    //获取文件状态信息
    s = fstat (fd, &amp;buf)
    
    //为打开的文件分配一个新的文件描述符
    fd = dup (fd)
    
    //创建一个管道
    s = pipe (&amp;fd[0])
    
    //对文件时行特殊操作
    s = ioctl (fd, request, argp)
    
    //检查文件的访问权限
    s = access (name, amode)
    
    //重命名文件
    s = rename (old, new)
    
    //文件加锁及其他操作
    s = fcntl (fd, cmd, ...)
</pre>
    
<p>
<strong>目录及文件系统管理Dir. &amp; File System Mgt:</strong>
</p>
<pre  class="brush:c">
    //创建一个新目录
    s = mkdir (name, mode)
    
    //删除一个目录
    s = rmdir (name)
    
    //创建一个新项name2，它指向name1
    s = link (name1, name2)
    
    //删除一个目录项
    s = unlink (name)
    
    //挂一个文件系统
    s = mount (special, name, flag)
    
    // Unmount a file system
    s = umount (special)
    
    //将缓存中的数据块回写到磁盘
    s = sync ()
    
    //改变工作目录
    s = chdir (dirname)
    
    //改变根目录
    s = chroot (dirname)
</pre>
    
<p>
<strong>保护Prodeciton:</strong>
</p>
<pre  class="brush:c">
    //修改文件的保护位
    s = chmod (name, mode)
    
    //获取调用进程的uid
    uid = getuid ()
    
    //获取调用进程的gid
    gid = getgid ()
    
    //设置调用进程的uid
    s = setuid (uid)
    
    //设置调用进程的gid
    s = setgid (gid)
    
    //修改文件的拥有者和组
    s = chown (name, owner, group)
    
    //修改文件模式掩码
    oldmask = umask (complmode)
    
</pre>
    
<p>
<strong>时间管理Time Management:</strong>
</p>
<pre  class="brush:c">
    //获取自19700101以来的秒数
    seconds = time (&amp;seconds)
    
    //获取自19700101以来的时间
    s = stime (tp)
    
    //设置文件最后访问时间
    s = utime (file, timep)
    
    //获取当前的用户和系统时间
    s = times (buffer)
    
</pre>
    
<h3 id="toc_1.4.1">进程管理的系统调用Process management</h3>

<p>
<strong>fork():</strong>
</p>
<ul>
<li>
fork是创建新进程的唯一途径

<li>
fork创建了一个调用者进程的精确副本：文件描述符，寄存器等所有内容

<li>
fork后原进程子进程各自执行，互不相关

<li>
fork时，两个进程的变量拥有相同的值，此后各自维护

<li>
fork()对子进程返回0， 对你进程返回一个正整数，为新子进程的pid

<li>
fork()可以以返回值区分是子进程还是你进程

<li>
shell框架demo:
<pre  class="brush:c">
        #define TRUE 1
        
        while (TRUE){                           /* repeat forever */
            type_prompt();                      /* display prompt on the screen */
            read_command(command, parameters);  /* read input from terminal */
            
            if (fork() != 0){                   /* fork off child process */
                /* Parent code. */
                waitpid(1, &amp;status, 0);         /* wait for child to exit */
            } else {
                /* Child code. */
                execve(command, parameters, 0); /* execute command */
            }
        }
</pre>

</ul>
    
<p>
<strong>exec():</strong>
</p>
<ul>
<li>
有三个参数：

<ol>
<li>
待执行文件名：用于替换内核映象

<li>
指向参数数组的指针

<li>
指向环境变量数组的指针

</ol>
<li>
简化版：<code>execl execv execle execve</code>

</ul>
 
<p>
<strong>main(argc, argv, envp):</strong>
</p>
<ul>
<li>
argc: 包括程序名在内的参数个数

<li>
argv: 指向参数数组的指针, argv[0]为程序名

<li>
envp: 环境变量指针

</ul>
 
<p>
<strong>进程的存储空间:</strong>
</p>
<ul>
<li>
分为三部分：正文段（text segment, 程序代码), 数据段（data segment,即变量), 堆栈段（stack segment)

<li>
data segment向上增长，stack segment向下增长；

<li>
statck segment的增长随程序的执行自动进行

<li>
data segment通过brk显示完成

<li>
data segment的结束指针必须小于stack segment的指针，不然会重叠，这是不允许的。

</ul>
 
<p>
<strong>getpid():</strong>
</p>
<ul>
<li>
获得当前进程的标识号

</ul>

<h3 id="toc_1.4.2">信号管理的系统调用System Calls for Signaling</h3>
<p>
<strong>收到一个未声明处理的signal:</strong>
</p>
<ul>
<li>
如果一个进程收到一个 <strong>未声明要接收的</strong> signal时，该进程被撤消，即被杀死

</ul>
 
<p>
<strong>声明要接收的signal:</strong>
</p>
<ol>
<li>
使用<code>sigaction</code>   

<li>
有两个参数，后两个是地址

<ul>
<li>
指明signal

<li>
要处理signal的procedure地址

<li>
signal原先处理procedure的地址

</ul>
</ol>
   
<p>
<strong>进程接收到一个signal时:</strong>
</p>
<ol>
<li>
将当前进程状态压栈

<li>
调用指定的signal处理procedure

<li>
处理结束，调用<code>sigreturn</code>,执行被signal中断的操作

</ol>

<p>
<strong>signal阻塞:</strong>
</p>
<ol>
<li>
signal可以被阻塞

<li>
阻塞的signal被扶起，直到被解除阻塞

<li>
<code>sigpromask</code>定义一个进程阻塞的信息集

<li>
<code>sigperding</code>查询因阻塞而挂起的信号集

<li>
<code>sigsuspend</code>进程用于设定阻塞信号位图，并将本身挂起

</ol>

<p>
<strong>忽略一个signal:</strong>
</p>
<ol>
<li>
<code>SIG_IGN</code>

<li>
忽略信号SIGINT
<pre  class="brush:c">
    sigaction(SIGINT, SIG_IGN, NULL);
</pre>

<li>
需要在执行exec前执行

</ol>

<p>
<strong>恢复一个signal默认处理:</strong>
</p>
<ol>
<li>
<code>SIG_DFL</code>

<li>
恢复信号SIGINT默认行为
<pre  class="brush:c">
    sigaction(SIGINT, SIG_DFL, NULL);
</pre>

</ol>
    
<p>
<strong>向指定进程发送一个signal:</strong>
</p>
<ol>
<li>
使用<code>kill</code>

<li>
signal 9(sigkill)不能被捕获或忽略

</ol>

<p>
<strong>alarm系统调用:</strong>
</p>
<ol>
<li>
参数：一个以秒为单位的间隔

<li>
时间到达，则向该进程发送一个sigalrm

<li>
任一时刻一个进程只能且个闹钟

</ol>
 
<p>
<strong>pause系统调用:</strong>
</p>
<ol>
<li>
挂起调用进程，直到信号到来

<li>
其他进程就可以使用cpu了

<li>
通常用于一个进程等待信号，又不需要什么操作时

</ol>

			</div>

			<div id="bottom">
				&copy; 2012 王兴朝
			</div>
		</div>
	<div>
</body>
</html>
