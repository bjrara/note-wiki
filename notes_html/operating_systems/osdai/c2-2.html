<!DOCTYPE html>
<html>
<head>

<title>Processes - Interprocess Communication </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../js/jquery-1.6.4.min.js"></script>

<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shCore.css">
<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shThemeRDark.css">
<script type="text/javascript" src="../../js/sh/scripts/shCore.js"></script>
<script type="text/javascript" src="../../js/sh/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../js/main.js"></script>
<script type="text/javascript" src="../../js/ASCIIMathML.js"></script>

<link rel="Stylesheet" type="text/css" href="../../style.css">
<link rel="Stylesheet" type="text/css" href="../../css/main.css">

</head>
<body>
	<div class="hidden">
		<input id="root_path" type="text" value="../../">
	</div>
	<div id="body-wrapper">
		<div id="container">
			<div id="top">
				<div id="page-title">
					<a href="../../index.html">烂笔头</a>
				</div>
				<ul id="top-nav">
				</ul>
			</div>
			<div id="middle">
				

<h1 id="toc_1">进程　Processes</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">进程　Processes</a>
<ul>
<li><a href="#toc_1.1">进程间通信　Interprocess Communication</a>
<ul>
<li><a href="#toc_1.1.1">竞争条件 Race Condition</a>
<li><a href="#toc_1.1.2">临界区 Critical Sections</a>
<li><a href="#toc_1.1.3">忙等待实现互斥</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">进程间通信　Interprocess Communication</h2>

<p>
<strong>三个要考虑的问题:</strong>
</p>
<ol>
<li>
一个进程如何传递消息给另一个进程

<li>
两个或多个进程参与临界活动critical activities时，如何不互相影响

<li>
存在信赖关系时，如何确定合适的次序

</ol>

<p>
这三个问题中的后两个同样对线程生效。因为线程共享地址空间，所以第一个问题对线程来说简单
</p>

<h3 id="toc_1.1.1">竞争条件 Race Condition</h3>
<p>
当两个或多个进程读写某些共享数据时，最终结果严格依赖于它们运行的时序，这种情况被称之为竞争条件。
</p>

<h3 id="toc_1.1.2">临界区 Critical Sections</h3>

<p>
解决竞争条件的问题，需要保证在同一时刻只有一个进程对共享数据进行读写。
</p>

<p>
换言之，我们需要 <strong>"互斥 mutual exclusion"</strong> :
</p>
<ul>
<li>
某种方法来保证当一个进程使用共享变量或文件时，其他进程不允许做同样的事情。

</ul>

<p>
<strong>Critical region</strong> or <strong>Critical setions</strong> : 我们把程序中访问共享内存的部分叫做临界区。
</p>
<ul>
<li>
如果使得两个进程不能同时处于临界区，就可以避免竞争条件

</ul>

<p>
一个好的方案需要满足四个条件：
</p>
<ol>
<li>
任何两个进程不能同时处于临界区

<li>
不对cpu的速度和数目做任何假设

<li>
临界区外的进程不能阻塞其他进程

<li>
一个进程不能在临界区外永远等待

</ol>

<h3 id="toc_1.1.3">忙等待实现互斥</h3>


<p>
<strong>关闭中断 Disabling Interrupts</strong>:
</p>
<ol>
<li>
每个进程在进入临界区后，关闭中断

<li>
中断关闭后，也不会发生任何时钟中断

<li>
CPU在进程间进行切换，只有在发生时钟中断或其他中断时

<li>
进入临界区的进程就可以检查或更新共享内存中的变量了

</ol>

<ol>
<li>
不应该给用户进程关闭中断的能力

<li>
关闭后，不在开启怎么办

<li>
对多核cpu也有问题，因为关闭中断只会关闭进程所在cpu的中断，其他cpu上运行的进程仍然可能访问共享内存

</ol>

<ol>
<li>
在内核进程在执行更新变量或列表的一些指令时，关闭中断将是很有用的

<li>
比如在就绪状态进程列表状态不一致时发生中断，就可能造成竞争条件

</ol>
<blockquote>
<strong>关闭中断对操作系统是一个很有用的功能，但对用户进程并不是合适的实现互斥的方法。</strong>
</blockquote>



<p>
<strong>锁变量 Lock Variables</strong>:
</p>

<p>
<strong>严格轮换 Strict Alternation:</strong>
</p>

<p>
<strong>Peterson的解决方案:</strong>
</p>

<p>
<strong>TSL指令 The TSL instruction:</strong>
</p>

			</div>

			<div id="bottom">
				&copy; 2012 王兴朝
			</div>
		</div>
	<div>
</body>
</html>
