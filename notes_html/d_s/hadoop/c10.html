<!DOCTYPE html>
<html>
<head>

<title>Administering Hadoop </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../../js/jquery-1.6.4.min.js"></script>

<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shCore.css">
<link rel="Stylesheet" type="text/css" href="../../js/sh/styles/shThemeRDark.css">
<script type="text/javascript" src="../../js/sh/scripts/shCore.js"></script>
<script type="text/javascript" src="../../js/sh/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../../js/main.js"></script>
<script type="text/javascript" src="../../js/ASCIIMathML.js"></script>

<link rel="Stylesheet" type="text/css" href="../../style.css">
<link rel="Stylesheet" type="text/css" href="../../css/main.css">

</head>
<body>
	<div class="hidden">
		<input id="root_path" type="text" value="../../">
	</div>
	<div id="body-wrapper">
		<div id="container">
			<div id="top">
				<div id="page-title">
					<a href="../../index.html">烂笔头</a>
				</div>
				<ul id="top-nav">
				</ul>
			</div>
			<div id="middle">
				
<h1 id="toc_1"> Administering Hadoop</h1>

<div class="toc">
<ul>
<li><a href="#toc_1"> Administering Hadoop</a>
<ul>
<li><a href="#toc_1.1">1 HDFS</a>
<ul>
<li><a href="#toc_1.1.1">1.1 持久化数据结构 </a>
<ul>
<li><a href="#toc_1.1.1.1">1.1.1 Namenode的目录结构 </a>
<li><a href="#toc_1.1.1.2">1.1.2 文件系统映象与编辑日志 </a>
<li><a href="#toc_1.1.1.3">1.1.3 Secondary Namenode的目录结构 </a>
<li><a href="#toc_1.1.1.4">1.1.4 Datanode的目录结构 </a>
</ul>
<li><a href="#toc_1.1.2">1.2 安全模式</a>
<li><a href="#toc_1.1.3">1.3 进入与离开安全模式</a>
<li><a href="#toc_1.1.4">1.4 审核日志</a>
<li><a href="#toc_1.1.5">1.5 工具集 </a>
</ul>
<li><a href="#toc_1.2">2 监控</a>
<li><a href="#toc_1.3">3 维护</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">1 HDFS</h2>

<h3 id="toc_1.1.1">1.1 持久化数据结构 </h3>
<p>
Namenode, Secondary Namenode, Datanode在磁盘上数据是如何存储组织的。
</p>

<h4 id="toc_1.1.1.1">1.1.1 Namenode的目录结构 </h4>
<pre  class="brush:bash">
    ${dfs.name.dir}/
    └── current/
        ├── VERSION
        ├── edits
        ├── fsimage
        └── fstime
</pre>
<ol>
<li>
dfs.name.dir 可以指定几个文件夹列表

<li>
每个文件夹中存放相同的数据

<li>
推荐其中一个使用NFS文件夹

<li>
文件VERSION：
<pre  class="brush:bash">
    #Tue Mar 10 19:21:36 GMT 2009
    namespaceID=134368441 #文件系统的唯一id号
                          #文件系统第一次格式化时创建
                          #用于检测新添加的datanode,因为它们不知道这个id号
    cTime=0 # namenode存储创建的时间
            # 对于新格式化的设备总是0
            # 升级时会更新这个时间
    storageType=NAME_NODE # 表名该文件夹存储什么样的数据
                          # 这个文件夹说明存放namenode的数据
    layoutVersion=-18 # 文件系统存储数据所使用结构的版本
                      # 是一个负数
                      # 升级会变成一个更小的负数，下一个版本-19
</pre>

</ol>

<h4 id="toc_1.1.1.2">1.1.2 文件系统映象与编辑日志 </h4>
<p>
<strong>编辑日志edit log:</strong>
</p>
<ol>
<li>
当对HDFS进行一个写操作时

<li>
就会在edit log中产生一条记录

<li>
namenode会在内存中保留一份整个HDFS的元数据

<ul>
<li>
它会在edit log更改后更改

<li>
它服务于对HDFS的读操作

</ul>
<li>
edit log的flush与sync

<ul>
<li>
它会在向客户端返回success code之前进行

<li>
namenode需要写多个目录

<li>
要保证每一个目录都写到了，才返回

</ul>
</ol>

<p>
<strong>fsimage:</strong>
</p>
<ol>
<li>
HDFS元数据checkpoint的持久化数据

<li>
并不是每个写操作都会触发更新，否则的话这个文件会增长过快

<li>
当namenode失败时

<ol>
<li>
会通过该文件恢复内存中的元数据

<li>
replay edit log中的操作

</ol>
<li>
namenode启动时就是进行的上述操作

</ol>
 
<p>
<strong>fsimage中的内容:</strong>
</p>
<ol>
<li>
HDFS中所有文件和目录的inodes

<li>
一个inode代表一个文件或目录的元数据

<li>
对于文件

<ul>
<li>
replication level

<li>
modification and access times

<li>
access permissions

<li>
block size

<li>
由哪些blocks组成

</ul>
<li>
对于目录

<ul>
<li>
modification time

<li>
permissions

<li>
quota metadata is stored.

</ul>
</ol>

<p>
edit log并没有大小限制，而namenode运行时，并不会有影响，
但当namenode重启时，会花很长的时间replay这个文件里的操作.
解决方案就是使用secondary namenode.
</p>

<p>
<strong>secondary namenode:</strong>
</p>
<ol>
<li>
用于根据主结点中的内存元数据生成checkpoint

<li>
进程的处理过程:

<ol>
<li>
The secondary asks the primary to roll its edits file, so new edits go to a new file.

<li>
The secondary retrieves fsimage and edits from the primary (using HTTP GET).

<li>
The secondary loads fsimage into memory, applies each operation from edits, then
    creates a new consolidated fsimage file.

<li>
The secondary sends the new fsimage back to the primary (using HTTP POST).

<li>
The primary replaces the old fsimage with the new one from the secondary and the
    old edits file with the new one it started in step 1. It also updates the fstime file to
    record the time that the checkpoint was taken.

</ol>
<li>
最后primary就会拥有一个最新的fsimage文件和一个小的edit log 文件

<li>
管理员可以手动触发这个操作: <code>hadoop dfsadmin -saveNamespace</code>

<li>
这个过程的自动触发有两种情况

<ul>
<li>
每小时触发一次，由属性 <code>fs.checkpoint.period</code> 指定

<li>
当edit log到达64MB时，由属性 <code>fs.checkpoint.size</code> 指定

</ul>
<li>
由上面可看出secondary namenode需要有和namenode相近的内存

</ol>
<p>
<img src="namenode-checkpointing.png" />
</p>

<h4 id="toc_1.1.1.3">1.1.3 Secondary Namenode的目录结构 </h4>
<pre  class="brush:bash">
    ${fs.checkpoint.dir}/
    ├── current/
    │   ├── VERSION
    │   ├── edits
    │   ├── fsimage
    │   └── fstime
    └── previous.checkpoint/
         ├── VERSION
         ├── edits
         ├── fsimage
         └── fstime
</pre>
<ol>
<li>
checkpointing进程完毕后，secondary namenode也会拥有一个检查点,放在文件夹previous.checkpoint里

<li>
这份数据可以作为namenode元数据的备份

<li>
secondary namenode的current，previous checkpoint和主namenode的元数据文件夹的结构是一样的

<li>
namenode失败时

<ol>
<li>
可以通过-importCheckpoint选项启动secondary namenode, 其将作为主namenode

<li>
它会从fs.checkpoint.dir文件夹里获取最新元数据放入dfs.name.dir里

</ol>
</ol>

<h4 id="toc_1.1.1.4">1.1.4 Datanode的目录结构 </h4>
<pre  class="brush:bash">
    ${dfs.data.dir}/
    └── current/
         ├── VERSION
         ├── blk_&lt;id_1&gt;
         ├── blk_&lt;id_1&gt;.meta
         ├── blk_&lt;id_2&gt;
         ├── blk_&lt;id_2&gt;.meta
         ├── ...
         ├── blk_&lt;id_64&gt;
         ├── blk_&lt;id_64&gt;.meta
         ├── subdir0/
         ├── subdir1/
         ├── ...
         └── subdir63/
</pre>
<ol>
<li>
datanode的目录不需要预先格式化，它会在启动时自动创建

<li>
同namenode一样，这里也会有一个VERSION文件

<ul>
<li>
namespceID, cTime 和 layoutVersion同namenode里的一样

<li>
namespceID是从namenode里接收的, 当datanode第一次连接时

<li>
storgeID是全局内是唯一的，namenode用它来唯一确定一个datanode

<li>
storageType用于表明该目录是做什么用的，这里是用于存储datanode数据的

</ul>
<li>
两种以blk_为前缀的文件

<ul>
<li>
一种就是HDFS块, 存储原始数据

<li>
第二种是HDFS块的元数据，以.meta为后缀， 存放了版本与类型信息，接着是一系列的校验值

</ul>
<li>
当HDFS块的数量到达一定数量后，会创建一个子目录，用于存放新的块和它们的元数据

<ul>
<li>
通过属性 <code>dfs.datanode.numblocks</code> 设置这个数据

<li>
保证了每个文件夹拥有可维护数量的文件

</ul>
<li>
若dfs.data.dir设置了多个目录，分属于不同的磁盘

<ul>
<li>
HDFS会轮循使用这些目录

<li>
不同的目录下不会有重复的块，只有不同的datanode间才有不同的块

</ul>
</ol>

<h3 id="toc_1.1.2">1.2 安全模式</h3>
<p>
<strong>Namenode的启动:</strong>
</p>
<ol>
<li>
加载fsimage进内存

<li>
接收edit log中的所有操作进内存

<li>
内存中构建出一份新的fsimage

<li>
创建一份新的空的edit log

<li>
开始监听RPC和HTTP请求

</ol>
 
<p>
<strong>安全模式:</strong>
</p>
<ol>
<li>
上面最后一步前是运行于安全模式的

<li>
可运行读元数据的操作，但也不保证完成

<li>
读文件的操作，只有当文件的块全部就绪后才可以

<li>
修改操作会全部失败

</ol>
 
<p>
<strong>namenode不维护hdfs block的位置信息:</strong>
</p>
<ol>
<li>
namenode不会持久化hdfs block的位置信息

<li>
namenode在内存中会有一份这样的信息

<li>
在安全模式下，datanode会告诉namenode它所包含的datanode列表

<li>
在安全模式下，不会对datanode 进行任何复本操作和删除操作

<li>
安全模式退出的条件：

<ol>
<li>
达到最小复本条件，再等30秒

<li>
最小复本条件默认是99%的块达到了复本要求

</ol>
<li>
新格式化的hdfs集群， namenode并不会进行安全模式

</ol>
<table>
<tr>
<td>
Property name
</td>
<td>
Type
</td>
<td>
Default value
</td>
<td>
Description
</td>
</tr>
<tr>
<td>
dfs.replication.min
</td>
<td>
int
</td>
<td>
1
</td>
<td>
The minimum number of replicas that have to be written for a write to be successful.
</td>
</tr>
<tr>
<td>
dfs.safemode.threshold.pct
</td>
<td>
float
</td>
<td>
0.999
</td>
<td>
The proportion of blocks in the system that must meet the minimum replication level defined by dfs.replication.min before the namenode will exit safe mode. Setting this value to 0 or less forces the namenode not to start in safe mode. Setting this value to more than 1 means the namenode never exits safe mode.
</td>
</tr>
<tr>
<td>
dfs.safemode.extension
</td>
<td>
int
</td>
<td>
30,000
</td>
<td>
The time, in milliseconds, to extend safe mode after the minimum replication condition defined by dfs.safemode.threshold.pct has been satisfied.  For small clusters (tens of nodes), it can be set to 0.
</td>
</tr>
</table>

<h3 id="toc_1.1.3">1.3 进入与离开安全模式</h3>
<ol>
<li>
查看namenode是否在安全模式
<pre  class="brush:bash">
     % hadoop dfsadmin -safemode get
</pre>

<li>
等待namenode退出安全模式
<pre  class="brush:bash">
     hadoop dfsadmin -safemode wait
     # command to read or write a file
</pre>

<li>
使namenode进入安全模式
<pre  class="brush:bash">
     % hadoop dfsadmin -safemode enter
</pre>

<li>
使namenode离开安全模式
<pre  class="brush:bash">
     % hadoop dfsadmin -safemode leave
</pre>

</ol>

<h3 id="toc_1.1.4">1.4 审核日志</h3>

<h3 id="toc_1.1.5">1.5 工具集 </h3>

<h2 id="toc_1.2">2 监控</h2>

<h2 id="toc_1.3">3 维护</h2>

			</div>

			<div id="bottom">
				&copy; 2012 王兴朝
			</div>
		</div>
	<div>
</body>
</html>
