%title Processes - Interprocess Communication 

=进程　Processes= 
%toc

==进程间通信　Interprocess Communication==

*三个要考虑的问题:*
# 一个进程如何传递消息给另一个进程
# 两个或多个进程参与临界活动critical activities时，如何不互相影响
# 存在信赖关系时，如何确定合适的次序

这三个问题中的后两个同样对线程生效。因为线程共享地址空间，所以第一个问题对线程来说简单

===竞争条件 Race Condition===
当两个或多个进程读写某些共享数据时，最终结果严格依赖于它们运行的时序，这种情况被称之为竞争条件。

===临界区 Critical Sections ===

解决竞争条件的问题，需要保证在同一时刻只有一个进程对共享数据进行读写。

换言之，我们需要 *"互斥 mutual exclusion"* :
* 某种方法来保证当一个进程使用共享变量或文件时，其他进程不允许做同样的事情。

*Critical region* or *Critical setions* : 我们把程序中访问共享内存的部分叫做临界区。
* 如果使得两个进程不能同时处于临界区，就可以避免竞争条件

一个好的方案需要满足四个条件：
# 任何两个进程不能同时处于临界区
# 不对cpu的速度和数目做任何假设
# 临界区外的进程不能阻塞其他进程
# 一个进程不能在临界区外永远等待

===忙等待实现互斥===


*关闭中断 Disabling Interrupts*:
# 每个进程在进入临界区后，关闭中断
# 中断关闭后，也不会发生任何时钟中断
# CPU在进程间进行切换，只有在发生时钟中断或其他中断时
# 进入临界区的进程就可以检查或更新共享内存中的变量了

# 不应该给用户进程关闭中断的能力
# 关闭后，不在开启怎么办
# 对多核cpu也有问题，因为关闭中断只会关闭进程所在cpu的中断，其他cpu上运行的进程仍然可能访问共享内存

# 在内核进程在执行更新变量或列表的一些指令时，关闭中断将是很有用的
# 比如在就绪状态进程列表状态不一致时发生中断，就可能造成竞争条件


    *关闭中断对操作系统是一个很有用的功能，但对用户进程并不是合适的实现互斥的方法。*



*锁变量 Lock Variables*:

*严格轮换 Strict Alternation:*

*Peterson的解决方案:*

*TSL指令 The TSL instruction:*
