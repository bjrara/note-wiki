<!DOCTYPE html>
<html>
<head>

<title>Gadget Framework</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../js/jquery-1.6.4.min.js"></script>

<link rel="Stylesheet" type="text/css" href="../js/sh/styles/shCore.css">
<link rel="Stylesheet" type="text/css" href="../js/sh/styles/shThemeRDark.css">
<script type="text/javascript" src="../js/sh/scripts/shCore.js"></script>
<script type="text/javascript" src="../js/sh/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../js/main.js"></script>

<link rel="Stylesheet" type="text/css" href="../style.css">
<link rel="Stylesheet" type="text/css" href="../css/main.css">

</head>
<body>
	<div class="hidden">
		<input id="root_path" type="text" value="../">
	</div>
	<div id="body-wrapper">
		<div id="container">
			<div id="top">
				<div id="page-title">
					<a href="../index.html">CTRIP</a>
				</div>
				<ul id="top-nav">
				</ul>
			</div>
			<div id="middle">
				

<div class="toc">
<ul>
<li><a href="#toc_1">Gadget Framework</a>
<ul>
<li><a href="#toc_1.1">概述</a>
<li><a href="#toc_1.2">设计</a>
<ul>
<li><a href="#toc_1.2.1">主要角色</a>
<li><a href="#toc_1.2.2">工作过程</a>
</ul>
<li><a href="#toc_1.3">模块</a>
<ul>
<li><a href="#toc_1.3.1">主要类图</a>
<li><a href="#toc_1.3.2">一个Demo</a>
<li><a href="#toc_1.3.3">构建Application</a>
<li><a href="#toc_1.3.4">消息体 </a>
<li><a href="#toc_1.3.5">过滤器 </a>
<li><a href="#toc_1.3.6">异常处理</a>
</ul>
<li><a href="#toc_1.4">计划任务</a>
<ul>
<li><a href="#toc_1.4.1">创建一个Task</a>
<li><a href="#toc_1.4.2">配置一个Task</a>
</ul>
<li><a href="#toc_1.5">配置</a>
<li><a href="#toc_1.6">ObjectFactory</a>
</ul>
</ul>
</div>

<h1 id="toc_1">Gadget Framework</h1>
<h2 id="toc_1.1">概述</h2>

<p>
目前logging2.0的collector使用了thrift进行了网络通信。实现上紧密耦合了thrift,以后扩展上很难，逻辑代码并没有和thrift的实现很好的隔离。
为了以后的协议扩展和协议替换或能够支持多种协议接口，并又很好的重用逻辑代码，达到解耦的目的，需要一个中间层框架。
</p>

<p>
借鉴现有的Struts2, Jersey, SpringMVC, Play等web框架的实现，他们都是基于HTTP协议，使用command模式处理请求的框架。但我们需要一个与协议无关，
通用的处理 request/response的框架。
</p>

<p>
<img src="gadget1.png" />
</p>

<h2 id="toc_1.2">设计</h2>
<p>
<img src="gadget_design.png" />
</p>

<h3 id="toc_1.2.1">主要角色</h3>
<ul>
<li>
<strong>Application:</strong> 容器类，管理框架内的所有类，交是请求的入口处

<li>
<strong>Request &amp; Response:</strong> 包装框架可以处理的请求，并返回的响应

<li>
<strong>Handler:</strong> 最终用于处理Request的类，可以调用其他Logical Service

<li>
<strong>RequestFilter:</strong> 在请求到达 Handler之前，可以通过一系列的Filter,进行一些预处理和统计类的工作。

<li>
<strong>ResponseFilter:</strong> 在 Handler处理并返回Response后，可以通过一系列的Filter,进行一些再加工和统计类的工作。

<li>
<strong>ExceptionMapper:</strong> 在处理过程中发生任何异常，可以定向到这里，进行统一处理，并返回相应的Response。

</ul>

<h3 id="toc_1.2.2">工作过程</h3>
<ol>
<li>
构建Reqeust对象

<li>
传给Application

<li>
Request会通过一系列的RequestFilter

<li>
Handler接收请求处理

<li>
Handler调用逻辑类处理

<li>
Handler构建关返回Response

<li>
Response通过一系列的ResponseFilter

<li>
Application返回Reponse

</ol>

<h2 id="toc_1.3">模块</h2>
<h3 id="toc_1.3.1">主要类图</h3>
<p>
<img src="gadget_classes.png" />
</p>

<h3 id="toc_1.3.2">一个Demo</h3>
<pre  class="brush:java">
    public void testGadget() throws Exception {
        GadgetConf gadgetConf = new GadgetConf();
        gadgetConf.setPackages("com.ctrip.freeway.gadget.a");
        gadgetConf.getTaskIntervals().put("gadget.task.TaskDemo.interval", 3);

        final Application application = new DefaultApplication(gadgetConf);

        int n = 10;
        Thread[] threads = new Thread[10];

        for (int i = 0; i &lt; n; i++) {
            Thread thread = new Thread() {
                @Override
                public void run() {
                    for (int l = 0; l &lt; 100; l++) {
                        Request&lt;Integer&gt; request = RequestBuilder.buildRequest();
                        request.setHeader(Headers.HOST.getCode(), "xingchaowang.ctrip.com");
                        request.setHeader(Headers.IP.getCode(), "192.168.1.1");
                        request.setHeader(Headers.COMMAND.getCode(), "add");

                        request.setBody(20);
                        System.out.println(Thread.currentThread().getId() + "\t:" + "request[" + 20 + "]");
                        
                        Response&lt;Integer&gt; response = application.handle(request);//处理请求
                        
                        System.out.println(Thread.currentThread().getId() + "\t:" + "response[" + response.getBody() + "]");
                    }
                }
            };
            thread.start();
            threads[i] = thread;
        }

        for (Thread thread : threads) {
            thread.join();
        }

        Thread.sleep(12000);
    }

</pre>

<h3 id="toc_1.3.3">构建Application</h3>
<pre  class="brush:java">
        GadgetConf gadgetConf = new GadgetConf();
        gadgetConf.setPackages("com.ctrip.freeway.gadget.a");
        
        Application application = new DefaultApplication(gadgetConf);
</pre>
<ol>
<li>
创建一个GadgetConf实例，传给它一个基包地址，可以是多个地址以逗号分隔

<li>
AbtractApplication会扫描这个些包，把其中的RequestFilter, ResponseFilter, Handler, ExceptionMapper构建起来

<li>
DefaultApplication负责具体的请求处理过程

<li>
Application的方法 <code>Response handle(Request request)</code> 负责接收请求并返回响应

</ol>

<h3 id="toc_1.3.4">消息体 </h3>
<ol>
<li>
Request和Response分别代表请求和响应

<li>
构成都分为Header和Body两部分
<pre  class="brush:java">
    private List&lt;Header&gt; headers = Lists.newArrayList();
    private T body;
</pre>

<li>
应该设的Header
<pre  class="brush:java">
    APPID("appId"),
    IP("ip"),
    HOST("host"),
    COMPRESS("compress"),
    SERIALIZE("serialize"),
    COMMAND("command");
</pre>

</ol>
    

<h3 id="toc_1.3.5">过滤器 </h3>
<ol>
<li>
RequestFilter:
<pre  class="brush:java">
    public interface RequestFilter {
        void filter(Request request);
    }
</pre>

<li>
ResponseFilter:
<pre  class="brush:java">
    public interface ResponseFilter {
        void filter(Response response);
    }
</pre>

<li>
Demo，用于记录一个请求的处理时间：
<pre  class="brush:java">
    public class AFilter implements RequestFilter, ResponseFilter {
        private Logger logger = LoggerFactory.getLogger(this.getClass());

        ThreadLocal&lt;Long&gt; start = new ThreadLocal&lt;Long&gt;();
        @Override
        public void filter(Request request) {
            logger.debug("request");
            start.set(System.currentTimeMillis());
        }

        @Override
        public void filter(Response response) {
            logger.debug("response");
            logger.info("Cost:" + (System.currentTimeMillis() - start.get()));
        }
    }
</pre>

</ol>

<h3 id="toc_1.3.6">异常处理</h3>
<ol>
<li>
在处理请求的时候出现任何异常都可以由一个ExceptionMapper来处理

<li>
ExceptionMapper

</ol>

<h2 id="toc_1.4">计划任务</h2>
<p>
框架中还内嵌了一个计划任务的框架，很方便的创建计划任务，并通过配置配置任务的执行策略
</p>

<h3 id="toc_1.4.1">创建一个Task</h3>
<ol>
<li>
Task接口
<pre  class="brush:java">
    public interface Task extends Runnable{
    }
</pre>

<li>
只要实现这个接口就可以了
<pre  class="brush:java">
    public class TaskDemo implements Task {
        private Logger logger = LoggerFactory.getLogger(TaskDemo.class);

        private int count = 0;

        @Override
        public void run() {
            logger.info("No. " + (++count));
        }
    }
</pre>

</ol>

<h3 id="toc_1.4.2">配置一个Task</h3>
<ol>
<li>
配置上面的Task, 每3s执行一次
<pre  class="brush:java">
        GadgetConf gadgetConf = new GadgetConf();
        gadgetConf.setPackages("com.ctrip.freeway.gadget.a");
        gadgetConf.getTaskIntervals().put("gadget.task.TaskDemo.interval", 3);

        final Application application = new DefaultApplication(gadgetConf);
</pre>

</ol>

<h2 id="toc_1.5">配置</h2>
<ol>
<li>
GadgetConf类存储了framework的配置信息

<li>
目前的配置信息分部分
<pre  class="brush:java">
    private String packages;
    private String objectFactory;
    private Map&lt;String, Integer&gt; taskIntervals = Maps.newConcurrentMap();
</pre>

<ol>
<li>
packages是一个以逗号分隔的包列表，Application实例化时会扫描这些包，以此来构建自己

<li>
taskInterveals存放对每一个task的策略配置

<li>
objectFactory是一个类名，框架使用该类创建对象

</ol>
</ol>
 
<h2 id="toc_1.6">ObjectFactory</h2>
<ol>
<li>
这是一个接口，默认有一个实现，该实现负责框架管理对象的创建
<pre  class="brush:java">
    public interface ObjectFactory {
        &lt;T&gt; T getInstance(Class&lt;T&gt; clazz) throws Exception;
    }
</pre>

<li>
该类是可以通过配置替换的，比如提供了一个GuiceObjectFactory, 和guice接合起来，实现依赖注入，简化编程，并提供了包含Logical Service在内的全局对象统一管理。

</ol>

			</div>

			<div id="bottom">
				&copy; 2012 王兴朝
			</div>
		</div>
	<div>
</body>
</html>
