<!DOCTYPE html>
<html>
<head>

<title>Agent Design and Implementation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<script type="text/javascript" src="../js/jquery-1.6.4.min.js"></script>

<link rel="Stylesheet" type="text/css" href="../js/sh/styles/shCore.css">
<link rel="Stylesheet" type="text/css" href="../js/sh/styles/shThemeRDark.css">
<script type="text/javascript" src="../js/sh/scripts/shCore.js"></script>
<script type="text/javascript" src="../js/sh/scripts/shAutoloader.js"></script>

<script type="text/javascript" src="../js/main.js"></script>

<link rel="Stylesheet" type="text/css" href="../style.css">
<link rel="Stylesheet" type="text/css" href="../css/main.css">

</head>
<body>
	<div class="hidden">
		<input id="root_path" type="text" value="../">
	</div>
	<div id="body-wrapper">
		<div id="container">
			<div id="top">
				<div id="page-title">
					<a href="../index.html">CTRIP</a>
				</div>
				<ul id="top-nav">
				</ul>
			</div>
			<div id="middle">
				
<h1 id="toc_1">Agent Design and Implementation</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">Agent Design and Implementation</a>
<ul>
<li><a href="#toc_1.1">Agent总体设计</a>
<ul>
<li><a href="#toc_1.1.1">功能目标</a>
<li><a href="#toc_1.1.2">配置信息</a>
<li><a href="#toc_1.1.3">数据流 </a>
</ul>
<li><a href="#toc_1.2">结构化数据 </a>
<li><a href="#toc_1.3">Agent数据采集</a>
<ul>
<li><a href="#toc_1.3.1">采集Log</a>
<ul>
<li><a href="#toc_1.3.1.1">核心类 </a>
<li><a href="#toc_1.3.1.2">FreewayLogger</a>
<li><a href="#toc_1.3.1.3">FreewayLoggerSender</a>
</ul>
<li><a href="#toc_1.3.2">采集Trace</a>
<ul>
<li><a href="#toc_1.3.2.1">核心类 </a>
<li><a href="#toc_1.3.2.2">ISample如何生效</a>
<li><a href="#toc_1.3.2.3">FreewayTracer</a>
<li><a href="#toc_1.3.2.4">何时触发清理数据</a>
<li><a href="#toc_1.3.2.5">ISpan的实现 </a>
<li><a href="#toc_1.3.2.6">FreewayTracer的startSpan方法</a>
<li><a href="#toc_1.3.2.7">FreewayTracer的continueSpan方法</a>
<li><a href="#toc_1.3.2.8">FreewayTraceSender</a>
</ul>
<li><a href="#toc_1.3.3">采集Metrics</a>
<ul>
<li><a href="#toc_1.3.3.1">核心类 </a>
<li><a href="#toc_1.3.3.2">IMetricImpl</a>
</ul>
</ul>
<li><a href="#toc_1.4">MessageConsumer</a>
<ul>
<li><a href="#toc_1.4.0.1">主要职责</a>
<li><a href="#toc_1.4.0.2">接收数据</a>
<li><a href="#toc_1.4.0.3">两个Queue</a>
<li><a href="#toc_1.4.0.4">一个线程 </a>
<li><a href="#toc_1.4.0.5">统计状态 </a>
</ul>
</ul>
<li><a href="#toc_1.5">MessageSender</a>
<li><a href="#toc_1.6">MessageManager</a>
<li><a href="#toc_1.7">配置信息</a>
<li><a href="#toc_1.8">Agent的启动 </a>
<li><a href="#toc_1.9">Agent的shutdown策略</a>
</ul>
</ul>
</div>

<h2 id="toc_1.1">Agent总体设计</h2>
<h3 id="toc_1.1.1">功能目标</h3>
<ol>
<li>
提供简便的api,供用户采集结构化数据：log、span(trace)、 metrics

<li>
将采集到的数据按一定的策略发往Collector

</ol>
 
<p>
<img src="logger-agent.png" />
</p>

<h3 id="toc_1.1.2">配置信息</h3>
<p>
<strong>LogConfig:</strong>
</p>
<ul>
<li>
该类代表了环境参数的配置

<li>
使用该agent的appId

<li>
该agent目的地collector的地址和端口

</ul>

<p>
<strong>ConfigManager:</strong>
</p>
<ul>
<li>
该类代表了采集数据的配置

<li>
log级别，是否开启trace等

<li>
单例模式

<li>
自身包含一个timer,会定期从collector刷新配置

</ul>

<p>
<strong>CollectorRegistry &amp; CollectorInfo:</strong>
</p>
<ul>
<li>
类CollectorInfo代表一个Collector实例

<li>
类CollectorRegistry负责初始化并维护Collector实例列表，并提供返回一个CollectorInfo的Api

<li>
目前实际上只有一个Collector实例，是根据LogConfig初始化的

<li>
类CollectorRegistry单例模式

<li>
ConfigManager和MessageSender通过类CollectorRegistry获取Collector实例（即CollectorInfo）

</ul>

<h3 id="toc_1.1.3">数据流 </h3>
<ol>
<li>
ILog ITrace IMetrics负责采集数据，并通过MessageConsumer的api将数据放入一个名为MessageList的队列

<li>
MessageConsumer会跑一个线程，根据条件取出MessageList中的数据并打包成一个Chunk,放入一个名为ChunkQueue的队列

<li>
MessageSender负责从ChunkQueue中取出数据，并发往Collector

</ol>

<h2 id="toc_1.2">结构化数据 </h2>

<h2 id="toc_1.3">Agent数据采集</h2>

<h3 id="toc_1.3.1">采集Log</h3>
<h4 id="toc_1.3.1.1">核心类 </h4>
<ul>
<li>
<strong>LogManager:</strong> 提供静态方法获取一个ILog实例 

<li>
<strong>ILog:</strong> 接口，提供了记录日志的各种api  

<li>
<strong>ILogSender:</strong> 接口，定义了一个send()方法，负责发送日志

</ul>

<h4 id="toc_1.3.1.2">FreewayLogger</h4>
<ul>
<li>
接口ILog的实现

<li>
主要方法writerLog()

<ol>
<li>
负责组装一个LogEvent对象

<li>
将LogEvent作为参数，调用ILogSender的send方法

</ol>
</ul>
     
<h4 id="toc_1.3.1.3">FreewayLoggerSender</h4>
<ul>
<li>
接口ILogSender的实现

<li>
包含一个ITacer的实例

<li>
send()方法的逻辑

<ol>
<li>
接收LogEvent作为参数

<li>
根据ConfigManager判定该LogEvent是否需要记录

<li>
如果需要记录，就将该LogEvent传给ITracer的实例

</ol>
</ul>

<h3 id="toc_1.3.2">采集Trace</h3>
<h4 id="toc_1.3.2.1">核心类 </h4>
<ul>
<li>
<strong>TraceManager:</strong> 提供静态方法，获取一个ITrace实例

<li>
<strong>ITrace:</strong> 接口，代表了一次Trace, 提供了记录log, 开启span, 清空追踪链的api

<li>
<strong>ISpan:</strong> 接口，用于表示一次追踪中的一次需要关注的调用

<li>
<strong>ISample:</strong> 接口，代表采样率，调用ITrace的startSpan时，传入这个接口的一个实例，决定是否对该span采样

<li>
<strong>ITraceSender:</strong> 接口，负责将数据发往目的地

</ul>
 
<h4 id="toc_1.3.2.2">ISample如何生效</h4>
<ol>
<li>
调用ITrace的startSpan时，传入这个接口的一个实例，决定是否对该span采样

<li>
如果对一个span决定了不采样，该span中内嵌的所有span将都不会采样

<li>
最佳实践就是对top span使用采样率

<li>
如果不指定采样率，默认使用AlwaysSample,总是采样

</ol>
 
<h4 id="toc_1.3.2.3">FreewayTracer</h4>
<ul>
<li>
接口ITrace的默认实现

<li>
<strong>主要职责:</strong>

<ol>
<li>
提供开启span的api，当前span（如果存在）会作为新开启span的父span, 从而组成链式结构

<li>
包含一个静态的ThreadLocal变量，存放当前线程内的current span, 线程内的span会组成一个链式结构

<li>
提供记录日志的api, 如果当前已开启追踪，则日志会挂在当前span的下面，并为对应的LogEvent设置一个traceId，如上一节的日志专用接口ILog记录的日志也会转由该类负责

<li>
根据条件触发，将数据交由ITraceSender处理

</ol>
</ul>
   
<h4 id="toc_1.3.2.4">何时触发清理数据</h4>
<ul>
<li>
调用ISpan的stop方法

<ol>
<li>
会触发ITrace的pop(ISpan)方法

<li>
将该ISpan下所有未关闭的子ISpan传给ITraceSender发送出去

<li>
将该ISpan传给ITraceSender发送出去

</ol>
<li>
调用ITrace的clear方法, 该方法属于保护方法

<ol>
<li>
如果存在current span, 将从current span开始，依次将整个span链将由ITraceSender处理 

<li>
防止死循环，处理span链的最大长度为50

<li>
清空current span

</ol>
<li>
调用ITrace的log方法，线程上下文中又不存在span时

</ul>
 
<h4 id="toc_1.3.2.5">ISpan的实现 </h4>
<ul>
<li>
<strong>MilliSpan:</strong> 代表一个普通的span

<li>
<strong>RootMilliSpan:</strong> 代表top span, span链中的第一个span

<li>
<strong>NullSpan:</strong> 特殊span, 对span不采样时，由该类填空

</ul>
 
<h4 id="toc_1.3.2.6">FreewayTracer的startSpan方法</h4>
<ol>
<li>
如果不存在current span, 创建一个RootMilliSpan, 并设为current span

<li>
如果存在current span, 创建一个MilliSpan, 并将其parent span指向current span, 再将其设为current span

</ol>
 
<h4 id="toc_1.3.2.7">FreewayTracer的continueSpan方法</h4>
<ol>
<li>
第一个开启的span是没有父span的，通过该方法可以人为的指定一个parentId, 和traceId

<li>
<strong>注意:调用该方法时，如果已开启过追踪，该追踪将会丢失，会以该span为根重新开启一个追踪 </strong> 

</ol>

<h4 id="toc_1.3.2.8">FreewayTraceSender</h4>
<ul>
<li>
ITraceSender的默认实现类

<li>
send(Span)方法：

<ol>
<li>
根据ConfigManager判定是否开启Trace

<li>
开启，将span发给MessageConsumer

<li>
未开启， 将span中类型为App的LogEvent抽取出来，发往MessageConsumer

</ol>
<li>
send(LogEvent)方法：

<ol>
<li>
看LogEvent的类型是否是App

<li>
不是，根据ConfigManager中是否开启trace来决定该log是否需要记录

<li>
是，根据ConfigManager中对log的配置来决定是否需要记录

<li>
若需要记录，将log发往MessageConsumer

</ol>
<li>
LogEventUtil:

<ol>
<li>
上面两个方法都会对LogEvent进行检查处理，超过设置的将会被截短

<li>
对LogEvent的限制：

<ul>
<li>
titile: 32字符，  agent里硬编码，在发送进截掉过长的

<li>
essage: 32k, 可配置的

<li>
additional info:

<ul>
<li>
最多8对

<li>
key最长32字符

<li>
value最多2k

<li>
都就在agent里硬编码

</ul>
<li>
生产上默认不保存Debug Log

</ul>
</ol>
</ul>

<h3 id="toc_1.3.3">采集Metrics</h3>
<h4 id="toc_1.3.3.1">核心类 </h4>
<ul>
<li>
<strong>MetricManager:</strong> 提供静态方法获取一个IMetric实例 

<li>
<strong>IMetric:</strong> 接口，提供了记录Metrics的各种api  

</ul>

<h4 id="toc_1.3.3.2">IMetricImpl</h4>
<ul>
<li>
接口IMetric的实现

<li>
主要方法writerMetric()

<ol>
<li>
根据ConfigManager判定是否开启Metrics

<li>
未开启，直接返回

<li>
负责组装一个MetricEvent对象

<li>
MetricEvent的 <strong>自定义Tag只能添加4个 </strong> ，超出的会丢弃（总数最多为8个）

<li>
如果需要添加AppIdTag

<li>
如果需要添加HostIpTag

<li>
将MetricEvent传给MessageConsumer

</ol>
</ul>

<h2 id="toc_1.4">MessageConsumer</h2>
<p>
访类是Agent中的一个核心类。
</p>

<h4 id="toc_1.4.0.1">主要职责</h4>
<ol>
<li>
提供api:process(LogEvent)、process(Span)、process(MetricEvent), 主要供FreewayTraceSender和IMetricImpl使用

<li>
持有两个Queue:MessageList, ChunkQueue

<li>
启动一个线程，不断将MessageList中成员打包成一个chunk放入ChunkQueue

</ol>
 
<h4 id="toc_1.4.0.2">接收数据</h4>
<ol>
<li>
通过api:process(LogEvent)、process(Span)、process(MetricEvent) 接收数据

<li>
接收的数据放入MessageList

</ol>

<h4 id="toc_1.4.0.3">两个Queue</h4>
<ul>
<li>
<strong>MessageList:</strong>

<ol>
<li>
用于存放原始数据：LogEvent Span MetricEvent

<li>
维护了一个内部状态size = LogEvent的数量 + Span中LogEvent的数量 + MetricEvent数量

<li>
最大容量：100000

<li>
超过最大容量，直接丢弃，不做任何记录

</ol>
</ul>
   
<ul>
<li>
<strong>ChunkQueue:</strong>

<ol>
<li>
存放Chunk对象

<li>
Queue是最大为1000，这是在MessageConsumer里可配的，目前在MessageManager里指定的

<li>
超过这个大小，chunk直接丢弃，MessageConsumer会记录丢弃的数量，并转换为Metrics

<li>
这个Queue是由MessageManager创建的

</ol>
</ul>

<h4 id="toc_1.4.0.4">一个线程 </h4>
<ul>
<li>
一个轮循线程，负责将MessageList中的原始灵气打包成一个chunk,放入ChunkQueue

<li>
触发打包chunk有两个条件：

<ol>
<li>
每隔一定时间，触发一次，该时间由服务端指定，通过ConfigManager可以获得，默认为

<li>
当MessageList的size大小超过50时触发，该值在MessageConsumer里是可配的，目前是在MessageManager里指定的

<li>
打包时最多将MessageList里的600个对象(Span中的每个LogEvent都会参与计数)打包成一个chunk, 该值是可配的，目前在AgentManager里指定

</ol>
<li>
<strong>所以这里有一个问题，只要ChunkQueue满了，哪怕MessageList不满，也会根据条件触发，不停的消耗，而导致数据丢失 </strong>

</ul>
 
<h4 id="toc_1.4.0.5">统计状态 </h4>
<ul>
<li>
MessageConsumer会不停的收集一些状态，并将其转换为Metrics, 并放入MessageList

<li>
每五分钟发送一次Metrics

<li>
列表： 

<ul>
<li>
consumer.message.total_count

<li>
consumer.message_queue.current_size

<li>
consumer.message_queue.max_size

<li>
consumer.lost_chunk.count

<li>
consumer.lost_logevent.count

</ul>
</ul>

<h2 id="toc_1.5">MessageSender</h2>
<ul>
<li>
负责向将chunk发往collector

<li>
实现了Runnable接口

<li>
拥有一个ChunkQueue的引用，实际上就是MessageConsumer中的ChunkQueue， 这个Queue是由MessageManager创建的

<li>
run方法：

<ol>
<li>
如果需要，将收集的状态转换成Metrics打包成chunk,放入ChunkQueue

<li>
从ChunkQueue取出一个chunk(timeout默认为500ms,如果一直取不到，最长会增加到10s),如果取到，到下一步，不存在(增加取chunk时timeout的值，最多到10s），回到1

<li>
将chunk传给sendChunk方法，负责具体的发送，该方法会阻塞，直到到chunk发送出去（在此之前，会将前一步取chunk的timeout恢复到默认值500ms)

<li>
关闭连接

<li>
回到 1

</ol>
<li>
sendChunk方法：

<ol>
<li>
如果需要开启连接

<li>
发送chunk

<li>
成功，返回

<li>
不成功，根据策略线程睡眠

<li>
回到1，进行重试

</ol>
<li>
sendChunk 重试时的睡眠策略：

<ol>
<li>
比较乱

<li>
大体是:0~5s,0~10s,0~15s,0~30s,0~5s,0~10s,0~15s,0~60s,0~5s,0~10s,0~15s,0~60s .....

</ol>
</ul>
   
<h2 id="toc_1.6">MessageManager</h2>
<ol>
<li>
这个是单例模式

<li>
将MessageConumer和MessageSender关联起来

<li>
负责根据配置创建MessageConsumer、MessageSender、ChunkQueue

<li>
MessageConsumer的数量只有一个

<li>
MessageSender的数量由2个，可配，默认值是在AgentManager中指定的

<li>
MessageSender有两类，但实际上只使用了一类（thrift),另外一类（http)没有

<li>
这里的逻辑可以简化

</ol>

<h2 id="toc_1.7">配置信息</h2>
<ol>
<li>
服务器端有针对每个App或IP的配置信息

<li>
这些信息控制日志级别，是否开启Trace,是否开启Metrics等

<li>
这些信息在Agent端存放在ConfigManager中

<li>
ConfigManager会每隔5分钟从Collecton端更新一次配置

<li>
ConfigManager是单例

<li>
第一次使用并创建这个单例时，会从Collector拉取一次配置

</ol>

<h2 id="toc_1.8">Agent的启动 </h2>
<ul>
<li>
整个Agent上下文的构建，是由第一次记Log Trace或Metrics触发的

<li>
FreewayLogSender、MetricsImpl或FreewayTraceSender中的ConfigManager.getInstance()

<ol>
<li>
会触发第一次从Collector拉取配置

<li>
<strong>有可能造成线程阻塞，timeout为20s</strong>

<li>
可以将ConfigManager中的pullAgentConfig()去掉解决

</ol>
<li>
MetricsImpl或FreewayTraceSender中的AgentManager.getMessageConsumer()

<ol>
<li>
会触发构建MessageManager MessageConsumer MessageSender

</ol>
</ul>
   
<h2 id="toc_1.9">Agent的shutdown策略</h2>
<ul>
<li>
MessageManager构建时会注册shutdownHook 

<li>
shutdown时会调用MessageManager的shutdown方法

<li>
MessageManager的shutdown方法

<ol>
<li>
会调用MessageConsumer的shudown方法

<li>
等待MessageConsumer关闭，最多等待10s

<li>
依次调用MessageSender的shutdown方法

<li>
退出（这里应该也有问题，应该等待MessageSender关闭在退出）

</ol>
<li>
MessageConsumer的shutdown方法

<ol>
<li>
立即触发将MessageList中的数据搬入ChunkQueue

<li>
问题是当MessageList的数据大于600时会搬不干净

</ol>
<li>
MessageSender的shutdown方法

<ol>
<li>
延迟5s关闭

<li>
chunkqueue也可能丢数据

</ol>
</ul>

			</div>

			<div id="bottom">
				&copy; 2012 王兴朝
			</div>
		</div>
	<div>
</body>
</html>
