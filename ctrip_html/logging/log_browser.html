<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../style.css">
<title>LogBrowser设计文档 </title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>


<h1 id="toc_1">LogBrowser设计文档</h1>

<div class="toc">
<ul>
<li><a href="#toc_1">LogBrowser设计文档</a>
<ul>
<li><a href="#toc_1.1">概述</a>
<li><a href="#toc_1.2">设计目标</a>
<li><a href="#toc_1.3">总体架构</a>
<ul>
<li><a href="#toc_1.3.1">数据源</a>
<li><a href="#toc_1.3.2">Restful Api</a>
<li><a href="#toc_1.3.3">web应用</a>
</ul>
<li><a href="#toc_1.4">程序结构</a>
<li><a href="#toc_1.5">领域模型</a>
<ul>
<li><a href="#toc_1.5.1">元数据</a>
<ul>
<li><a href="#toc_1.5.1.1">成员及关系</a>
<li><a href="#toc_1.5.1.2">实体定义</a>
<li><a href="#toc_1.5.1.3">数据来源</a>
</ul>
<li><a href="#toc_1.5.2">配置数据</a>
<ul>
<li><a href="#toc_1.5.2.1">Agent配置</a>
<li><a href="#toc_1.5.2.2">Namespace配置</a>
</ul>
<li><a href="#toc_1.5.3">日志数据</a>
<ul>
<li><a href="#toc_1.5.3.1">成员及关系</a>
<li><a href="#toc_1.5.3.2">实体定义</a>
</ul>
<li><a href="#toc_1.5.4">统计报表数据</a>
</ul>
<li><a href="#toc_1.6">Restful Api 接口</a>
<ul>
<li><a href="#toc_1.6.1">设计理念</a>
<li><a href="#toc_1.6.2">接口定义</a>
<ul>
<li><a href="#toc_1.6.2.1">Meta Api</a>
<li><a href="#toc_1.6.2.2">Configration Api</a>
<li><a href="#toc_1.6.2.3">Data Api</a>
<li><a href="#toc_1.6.2.4">Report Api</a>
</ul>
<li><a href="#toc_1.6.3">核心设计</a>
<ul>
<li><a href="#toc_1.6.3.1">元数据获取</a>
<li><a href="#toc_1.6.3.2">查询日志数据</a>
<li><a href="#toc_1.6.3.3">查询日志报表</a>
</ul>
</ul>
<li><a href="#toc_1.7">Log-Browser日志应用</a>
<ul>
<li><a href="#toc_1.7.1">页面流设计</a>
<ul>
<li><a href="#toc_1.7.1.1">Page 1: 主页</a>
<li><a href="#toc_1.7.1.2">Page 2: 部门列表</a>
<li><a href="#toc_1.7.1.3">Page 3: 应用列表</a>
<li><a href="#toc_1.7.1.4">Page 4: 服务器列表</a>
<li><a href="#toc_1.7.1.5">Page 5: 服务器日志报表</a>
<li><a href="#toc_1.7.1.6">Page 6: 日志列表</a>
</ul>
<li><a href="#toc_1.7.2">页面流方案二</a>
<li><a href="#toc_1.7.3">页面逻辑设计</a>
<li><a href="#toc_1.7.4">基础架构</a>
</ul>
<li><a href="#toc_1.8">其他模块关联更改</a>
<ul>
<li><a href="#toc_1.8.1">HBase 日志查询优化</a>
<ul>
<li><a href="#toc_1.8.1.1">现有方案及问题</a>
<li><a href="#toc_1.8.1.2">优化方案</a>
<li><a href="#toc_1.8.1.3">rawlogindex表设计</a>
<li><a href="#toc_1.8.1.4">写实现</a>
<li><a href="#toc_1.8.1.5">查询实现</a>
</ul>
<li><a href="#toc_1.8.2">HBase 日志统计</a>
<ul>
<li><a href="#toc_1.8.2.1">表logstatistics设计</a>
<li><a href="#toc_1.8.2.2">HBaseWriter 日志统计模块</a>
</ul>
</ul>
<li><a href="#toc_1.9">部署架构</a>
<ul>
<li><a href="#toc_1.9.1">域名</a>
<li><a href="#toc_1.9.2">部署图</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_1.1">概述</h2>
<p>
Logging 2.0上线，公司内越来越多的应用接入，各应用部门对及时快速准确获得相应日志的需求越来越高，也越来越多样化。 
目前我们已经提供了日志查询的应用LogView和日志转存功能。但还不能真正满足用户的需求。
</p>

<p>
为了提供给用户更好的服务与用户体验，现开启了这个新项目LogBrowser，提供给用户以直觉导航浏览式的方式查看日志。
</p>

<p>
当前Logging2.0自身的应用，数量已超过6个，主要有LogView TraceView，而且全都基于开源项目，架构也不统一，难以扩展与维护,
浪费了大量的人力资源，而且不能带来令人满意的回报。
接下来的目标就是将这些应用慢慢整合，最终合并成两个应用，一个用于提供数据的RestfulApi, 一个用于提供Web界面操作的LogBrowser.
接下来以这个项目为契机，开启这种进化。
</p>

<p>
Logging2.0当前后端的HBase设计也存在一定的问题，在查询速度与并发访问下表现并不能使人满意，存在大量浪费带宽的行为。
在此次项目开发中，也会使用新方案，改善这种情况。
</p>

<h2 id="toc_1.2">设计目标</h2>
<ul>
<li>
<strong>提供一个可扩展的应用基础架构</strong>

<ol>
<li>
当前的应用会慢慢合并到LogBrowser中

<li>
以后新开发的应用在LogBrowser中扩展

</ol>
<li>
<strong>数据服务分离</strong>

<ol>
<li>
开发Restful Api提供专门的数据服务

<li>
LogBrowser只提供界面服务，通过Ajax与Restful Api通信，获取相应数据

</ol>
</ul>

<h2 id="toc_1.3">总体架构</h2>

<p>
<img src="log-browser.png" />
</p>

<p>
总体架构如上，分为三种角色: *数据源 * 、 <strong>Restful Api接口</strong> 、 <strong>web应用</strong>
</p>

<h3 id="toc_1.3.1">数据源</h3>
<p>
数据源分为两种，HBase和MySql.
</p>

<p>
<strong>HBase:</strong>
</p>
<ul>
<li>
用于存储海量的日志数据，主要包含四种结构化数据：log, span, metric, event

<li>
HBase里的数据主要是通过HBaseWriter写进来的

</ul>

<p>
<strong>MySql:</strong>
</p>
<ul>
<li>
MySql里主要用于存储Central Logging 2.0的辅助数据，比如元数据等。

<ol>
<li>
关于App的元数据（appId, department, server etc.)

<li>
配置数据（日志的配置信息，metric namespace的配置信息）

</ol>
<li>
MySql中的数据来源有两种：第三方系统和通过 api 录入的

<ol>
<li>
第三方来源：app相关的元数据

<li>
api录入:配置信息

</ol>
</ul>

<h3 id="toc_1.3.2">Restful Api</h3>
<ul>
<li>
以上面两种数据源为基础，包装并暴露合理的api接口，提供数据服务

<li>
设计restful api分为三类

<ol>
<li>
Meta Api.  <code>logging/apps</code> 获取所有的app列表

<li>
Config Api. <code>logging/config/agent-configs</code> 获取agent的日志配置

<li>
Data Api. <code>logging/data/logs?app=110101&amp;startDate=2013-01-01 18:00:00</code> 获取某个app指定时间段的日志数据 

</ol>
<li>
restful api可以返回两种数据：xml json

</ul>

<h3 id="toc_1.3.3">web应用</h3>
<ul>
<li>
Log-Browser应用

<li>
以导航式方式查看日志数据

<li>
根据用户的点击导航，从restful api获取数据，以友好美观的方式呈现给用户

</ul>

<h2 id="toc_1.4">程序结构</h2>
<p>
当前Central-Logging 2.0的组成：
</p>

<p>
<img src="central-logging-project.png" />
</p>

<p>
Central-Logging 2.0中Log-Browser相关的将划分为三个子项目，挂在Central-Logging 2.0下面。
</p>
<ul>
<li>
<strong>central-logging-domain:</strong> 

<ol>
<li>
用于定义领域模型对应的java bean和相关信息，作为jar包被其他子项目依赖。

<li>
基包: <code>com.ctrip.freeway.domain</code>

</ol>
<li>
<strong>central-logging-restful:</strong>

<ol>
<li>
用于开发Restful Api接口，将作为一个web 项目发布

<li>
基包: <code>com.ctrip.framework.freeway.rest</code>

</ol>
<li>
<strong>central-logging-web:</strong>

<ol>
<li>
用户直接使用的产品，提供界面，作为web 项目发布。

<li>
基包: <code>com.ctrip.framework.freeway.web</code>

</ol>
</ul>

<h2 id="toc_1.5">领域模型</h2>
<p>
Central Logging 2.0中的数据模型分为四类:meta data(*元数据 *), configration data(<strong>配置数据</strong>), 
log data(<strong>日志数据</strong>: log metric span event), report data(<strong>统计报表数据</strong>).
这些领域模型对应的Java Bean在项目central-loggging-domain里定义
</p>

<h3 id="toc_1.5.1">元数据</h3>
<h4 id="toc_1.5.1.1">成员及关系</h4>
<p>
<img src="domain-meta-entity.png" />
</p>

<p>
元数据的领域模型主要是以App为核心展开的：
</p>
<ul>
<li>
<strong>Department:</strong> 代表携程的一个部门， 一层结构。一个部门下可以有多个应用

<li>
<strong>App:</strong> 代表一个具体的应用。和Department的关系是多对一。

<li>
<strong>AppServer:</strong> 代表运营环境中一台具体的服务器。服务器上可以运行一个具体的应用。

<ul>
<li>
上图中和App的关系是多个一，实际上可能是多对多，因为一台服务器上可以运行多个App.

</ul>
<li>
<strong>AppService:</strong> 代表一个被trace的服务，比如一个具体的WebService接口。和App的关系是多对一。

<li>
<strong>ServiceSpan:</strong> 代表服务中的一个方法。比如某个WebService接口中的一个方法。

</ul>

<p>
<strong>总结:</strong> 一个部门下可以有多个应用;一个应用可以有多台服务器;一个应用可以多个服务;一个服务可以有多个方法
</p>


<h4 id="toc_1.5.1.2">实体定义</h4>

<p>
<strong>Department:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
name
</td>
<td>
String
</td>
<td>
部门名称
</td>
</tr>
<tr>
<td>
description
</td>
<td>
String
</td>
<td>
部门描述
</td>
</tr>
</table>
</p>

<p>
<strong>App:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
appId
</td>
<td>
String
</td>
<td>
公司分配给这个应用的一个应用号，通常为6位数字
</td>
</tr>
<tr>
<td>
name
</td>
<td>
String
</td>
<td>
应用名称
</td>
</tr>
<tr>
<td>
description
</td>
<td>
String
</td>
<td>
应用描述
</td>
</tr>
<tr>
<td>
appServers
</td>
<td>
List&lt;AppServer&gt;
</td>
<td>
应用拥有的服务器列表
</td>
</tr>
<tr>
<td>
appServices
</td>
<td>
List&lt;AppService&gt;
</td>
<td>
应用中被trace的服务列表
</td>
</tr>
</table>
</p>

<p>
<strong>AppServer:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
hostName
</td>
<td>
String
</td>
<td>
服务器的hostName
</td>
</tr>
<tr>
<td>
ip
</td>
<td>
String
</td>
<td>
服务器的ip
</td>
</tr>
</table>
</p>

<p>
<strong>AppService:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
name
</td>
<td>
String
</td>
<td>
service名称
</td>
</tr>
<tr>
<td>
serviceSpans
</td>
<td>
List&lt;ServiceSpan&gt;
</td>
<td>
服务所拥有的方法列表
</td>
</tr>
</table>
</p>

<p>
<strong>ServiceSpan:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
name
</td>
<td>
String
</td>
<td>
方法名称
</td>
</tr>
</table>
</p>


<h4 id="toc_1.5.1.3">数据来源</h4>
<p>
无数数据的来源分为两种：
</p>
<ul>
<li>
Department App AppServer来自系统部的api, 我们定期更新

<li>
AppService ServiceSpan是由我们的HBaseWriter收集的，通过Restful Api更新

</ul>

<h3 id="toc_1.5.2">配置数据</h3>
<p>
配置数据分为两类，一类是对Agent的配置信息，一类是对Metric Namespace的配置信息。
</p>

<h4 id="toc_1.5.2.1">Agent配置</h4>
<p>
由类AgentConfig表示
</p>

<p>
<img src="domain-agent-config.png" />
</p>

<p>
<strong>AgentConfig:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
key
</td>
<td>
String
</td>
<td>
指定的一个Key,将确定对谁生效。通常为一个appId或server ip, 特殊key:"global",代表agent的默认配置
</td>
</tr>
<tr>
<td>
appLogEnabled
</td>
<td>
boolean
</td>
<td>
表明是否开启日志
</td>
</tr>
<tr>
<td>
traceEnabled
</td>
<td>
boolean
</td>
<td>
表明是否开启trace
</td>
</tr>
<tr>
<td>
metricEnabled
</td>
<td>
boolean
</td>
<td>
表明是否开启metrics
</td>
</tr>
<tr>
<td>
appLogLevel
</td>
<td>
LogLevel
</td>
<td>
日志级别，前提需要开启appLogEnabled
</td>
</tr>
<tr>
<td>
traceLogLevel
</td>
<td>
LogLevel
</td>
<td>
trace中的日志级别，前提需要开启traceLogEnabled
</td>
</tr>
<tr>
<td>
flushPeriod
</td>
<td>
int
</td>
<td>
毫秒，agent中打包chunk的频率
</td>
</tr>
<tr>
<td>
maxMessageSize
</td>
<td>
int
</td>
<td>
KB，一条 log中message的最大size
</td>
</tr>
<tr>
<td>
urlLogSampleRate
</td>
<td>
double
</td>
<td>
url trace的采样率
</td>
</tr>
</table>
</p>

<h4 id="toc_1.5.2.2">Namespace配置</h4>
<p>
目前只有metrics使用namespace, namespace决定了读写权限，和使用的hbase实例和table名称。
</p>

<p>
<img src="domain-namespace.png" />
</p>

<ul>
<li>
HBase代表一个HBase实例

<li>
MetricNamespace代表一个metric namespace的定义

</ul>
 
<p>
<strong>HBase:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
zkquorum
</td>
<td>
String
</td>
<td>
Zookeeper 结点列表
</td>
</tr>
<tr>
<td>
basePath
</td>
<td>
String
</td>
<td>
HBase实例在HDFS中的路径
</td>
</tr>
<tr>
<td>
isMeta
</td>
<td>
boolean
</td>
<td>
HBase实例是否存储元数据
</td>
</tr>
<tr>
<td>
isUnique
</td>
<td>
boolean
</td>
<td>
HBase实例是否存储unique id
</td>
</tr>
</table>
</p>

<p>
<strong>MetricNamespace:</strong>
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
zkquorum
</td>
<td>
String
</td>
<td>
Zookeeper 结点列表
</td>
</tr>
<tr>
<td>
basePath
</td>
<td>
String
</td>
<td>
HBase实例在HDFS中的路径
</td>
</tr>
<tr>
<td>
isMeta
</td>
<td>
boolean
</td>
<td>
HBase实例是否存储元数据
</td>
</tr>
<tr>
<td>
isUnique
</td>
<td>
boolean
</td>
<td>
HBase实例是否存储unique id
</td>
</tr>
</table>
</p>

<h3 id="toc_1.5.3">日志数据</h3>
<p>
主要是我们Logging系统收集的四种结构化数据：log span metric event:
</p>

<h4 id="toc_1.5.3.1">成员及关系</h4>
<p>
<img src="domain-log.png" />
</p>

<ul>
<li>
<strong>BaseEventDomain:</strong> 四种结构化数据的基类，基本上代表了数据来源。

<li>
<strong>Log:</strong> 代表一条日志

<li>
<strong>Span:</strong> 代表一个trace实例中的一个方法追踪，其中可以内嵌Log

<li>
<strong>Metric:</strong> 代表一个度量的点

<li>
<strong>Event:</strong> 代表一个事件

</ul>

<p>
<strong>总结:</strong> Log可以单独记，也可以和Span关联起来，它们之间是多对0关系。
Span本身也可以组成树形结构，一个span可以有一个父span, 一个span可能有多个子span.
所以span与span之间是多对一的关系。
</p>

<h4 id="toc_1.5.3.2">实体定义</h4>

<p>
<strong>BaseEventDomain:</strong> 
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
type
</td>
<td>
String
</td>
<td>
数据分类，保留使用
</td>
</tr>
<tr>
<td>
hostName
</td>
<td>
String
</td>
<td>
数据来源的服务器的host name
</td>
</tr>
<tr>
<td>
hostIP
</td>
<td>
String
</td>
<td>
数据来源的服务器的ip
</td>
</tr>
<tr>
<td>
processId
</td>
<td>
String
</td>
<td>
产生该数据的进程号
</td>
</tr>
</table>
</p>

<p>
<strong>Log:</strong> 
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
rowKey
</td>
<td>
String
</td>
<td>
Log在Hbase中的row key
</td>
</tr>
<tr>
<td>
logId
</td>
<td>
long
</td>
<td>
Log的id号，一般由agent产生，并不是全局唯一
</td>
</tr>
<tr>
<td>
logType
</td>
<td>
LogType
</td>
<td>
Log的类型
</td>
</tr>
<tr>
<td>
logLevel
</td>
<td>
LogLevel
</td>
<td>
Log的level
</td>
</tr>
<tr>
<td>
threadId
</td>
<td>
long
</td>
<td>
产生log的线程号
</td>
</tr>
<tr>
<td>
traceId
</td>
<td>
long
</td>
<td>
Log产生时，如果存在trace,trace的Id号
</td>
</tr>
<tr>
<td>
spanRowKey
</td>
<td>
String
</td>
<td>
如果Log是在某个Span生命周期记的，对应Span在HBase中的row key
</td>
</tr>
<tr>
<td>
source
</td>
<td>
String
</td>
<td>
Log的来源，比如某个类名
</td>
</tr>
<tr>
<td>
title
</td>
<td>
String
</td>
<td>
日志title
</td>
</tr>
<tr>
<td>
message
</td>
<td>
String
</td>
<td>
日志内容
</td>
</tr>
<tr>
<td>
attributs
</td>
<td>
String
</td>
<td>
日志附加属性，键值对
</td>
</tr>
<tr>
<td>
createdTime
</td>
<td>
String
</td>
<td>
数据来源的服务器的host name
</td>
</tr>
</table>
</p>

<p>
<strong>Span:</strong> 
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
rowKey
</td>
<td>
String
</td>
<td>
Span在Hbase中的row key
</td>
</tr>
<tr>
<td>
serviceName
</td>
<td>
String
</td>
<td>
对应的service name
</td>
</tr>
<tr>
<td>
spanName
</td>
<td>
String
</td>
<td>
对应的service的method name
</td>
</tr>
<tr>
<td>
spanType
</td>
<td>
SpanType
</td>
<td>
Log的level
</td>
</tr>
<tr>
<td>
threadId
</td>
<td>
long
</td>
<td>
产生span的线程号
</td>
</tr>
<tr>
<td>
traceId
</td>
<td>
long
</td>
<td>
span所属trace的Id号
</td>
</tr>
<tr>
<td>
spanId
</td>
<td>
long
</td>
<td>
span的id号，一般由agent产生，并不是全局唯一
</td>
</tr>
<tr>
<td>
parentId
</td>
<td>
long
</td>
<td>
此span父span的id号
</td>
</tr>
<tr>
<td>
startTime
</td>
<td>
String
</td>
<td>
span的开始时间
</td>
</tr>
<tr>
<td>
stopTime
</td>
<td>
String
</td>
<td>
span的结束时间
</td>
</tr>
<tr>
<td>
isUnfinished
</td>
<td>
String
</td>
<td>
此span是否是正常结束的，通过stop方法
</td>
</tr>
</table>
</p>

<p>
<strong>Metric:</strong> 
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
name
</td>
<td>
String
</td>
<td>
metric的名称
</td>
</tr>
<tr>
<td>
namespace
</td>
<td>
String
</td>
<td>
metric所属的namespace, 用于目的地和安全
</td>
</tr>
<tr>
<td>
value
</td>
<td>
String
</td>
<td>
metric这个点的值
</td>
</tr>
<tr>
<td>
metricValueType
</td>
<td>
MetricValueType
</td>
<td>
值的类型
</td>
</tr>
<tr>
<td>
tags
</td>
<td>
List&lt;Attribute&gt;
</td>
<td>
这个metric的tag value对
</td>
</tr>
<tr>
<td>
createdTime
</td>
<td>
long
</td>
<td>
此metric的创建时间
</td>
</tr>
</table>
</p>

<p>
<strong>Event:</strong> 
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
name
</td>
<td>
String
</td>
<td>
事件的名称
</td>
</tr>
<tr>
<td>
namespace
</td>
<td>
String
</td>
<td>
事件所属的namespace
</td>
</tr>
<tr>
<td>
attributes
</td>
<td>
List&lt;Attribute&gt;
</td>
<td>
事件的属性对
</td>
</tr>
<tr>
<td>
createdTime
</td>
<td>
long
</td>
<td>
事件的创建时间
</td>
</tr>
</table>
</p>

<h3 id="toc_1.5.4">统计报表数据</h3>
<p>
Central Logging 2.0中为app统计一日志数据。
</p>

<p>
<img src="domain-statistics.png" />
</p>

<p>
用于表示一个app的一台server在一定时间范围内的各种日志level的数量。
</p>

<p>
<strong>LogStatistics:</strong> 
<table>
<tr>
<th>
属性
</th>
<th>
类型
</th>
<th>
说明
</th>
</tr>
<tr>
<td>
appId
</td>
<td>
String
</td>
<td>
要统计的应用号
</td>
</tr>
<tr>
<td>
hostName
</td>
<td>
String
</td>
<td>
要统计的server host name
</td>
</tr>
<tr>
<td>
hostIP
</td>
<td>
String
</td>
<td>
要统计的server ip
</td>
</tr>
<tr>
<td>
startTime
</td>
<td>
long
</td>
<td>
统计开始的时间
</td>
</tr>
<tr>
<td>
dateRange
</td>
<td>
long
</td>
<td>
要统计的时间长度
</td>
</tr>
<tr>
<td>
infoCount
</td>
<td>
long
</td>
<td>
统计范围内info log的数量
</td>
</tr>
<tr>
<td>
warnCount
</td>
<td>
long
</td>
<td>
统计范围内warn log的数量
</td>
</tr>
<tr>
<td>
errorCount
</td>
<td>
long
</td>
<td>
统计范围内error log的数量
</td>
</tr>
</table>
</p>

<h2 id="toc_1.6">Restful Api 接口</h2>
<p>
为了实现数据分离，接口化。需要把CentralLogging 2中所有的内部通信和外部接口包装成Restful 的接口。
</p>

<p>
<img src="logging-rest.png" alt="logging-rest.png" style="width:900px" />
</p>

<h3 id="toc_1.6.1">设计理念</h3>

<p>
<strong>在Restful Api中，主要将前面定义的领域模型转换成Restful中的资源，对这些资源进行查询，创建，更新等操作，而支持的资源表现形式为XML和JSON.</strong>
</p>

<p>
如上图，把Restful Api分为四类：meta, config, data, report
</p>
<ul>
<li>
<strong>meta:</strong> 元数据接口，比如公司的部门信息，数据中心信息，服务器信息，应用信息等。

<li>
<strong>config:</strong> 配置接口，所有和配置相关的api放在这个类别下面。比如agent的配置，metrics的namespace配置。

<li>
<strong>data:</strong> 数据接口，主要用于暴露logging收集到的结构化数据。比如根据数据查询日志数据

<li>
<strong>report:</strong> 统计报表数据，用于暴露logging自身统计的一些数据。比如每个app记录日志的情况

</ul>
 
<h3 id="toc_1.6.2">接口定义</h3>

<h4 id="toc_1.6.2.1">Meta Api</h4>

<p>
 <strong>部门相关:</strong>
</p>
 
<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/department</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取所有的部门列表
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/department/{departmentCode}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取指定部门的信息
</td>
</tr>
</table>

<p>
<strong>数据中心相关:</strong> 
</p>
 
<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/idcs</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取所有的数据中心列表
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/idcs/{idcCode}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取指定数据中心的信息
</td>
</tr>
</table>

<p>
<strong>应用相关:</strong>
</p>
 
<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/apps</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
Query String
</td>
<td>
JSON/XML
</td>
<td>
获取应用列表，可以根据条件过虑，比如通过Query String指定返回某个部门的所有应用
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/apps/{appId}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取指定应用的信息
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/apps/{appId}/appServices</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取某个应用的开启过trace的service列表
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/apps/{appId}/appServices/{serviceName}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取某个应用的某个具体的Service
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/meta/apps/{appId}/appServices/{serviceName}/serviceSpans</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取某个应用的某个具体的Service的所有追踪过的方法
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
POST
</td>
<td>
String
</td>
<td>
NA
</td>
<td>
为某个应用的某个具体的Service添加一个追踪过的方法
</td>
</tr>
</table>

<h4 id="toc_1.6.2.2">Configration Api</h4>

<p>
<strong>Agent配置相关:</strong>
</p>

<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/config/agent-configs</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取所有的Agent配置列表
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
POST
</td>
<td>
JSON/XML
</td>
<td>
NA
</td>
<td>
增加一个具体Agent的配置
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/config/agent-configs/{key:appId or ip}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取一个具体agent的配置信息
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
PUT
</td>
<td>
JSON/XML
</td>
<td>
NA
</td>
<td>
更新一个具体agent的配置信息
</td>
</tr>
</table>

<p>
<strong>Metric Namespace配置相关:</strong>
</p>

<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/config/metric-namespaces</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取所有的metric namespace的配置列表
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/config/metric-namespaces/{namespaceName}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取一个具体的metric namespace的配置信息
</td>
</tr>
</table>

<h4 id="toc_1.6.2.3">Data Api</h4>
<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/data/logs</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
Query String
</td>
<td>
JSON/XML
</td>
<td>
根据查询条件获取日志列表，比如某个app某个时间段内所有的Error日志
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/data/logs/{rowKey}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取一条具体的日志
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/data/spans</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
Query String
</td>
<td>
JSON/XML
</td>
<td>
根据查询条件获取追踪信息，比如某个traceId,获取一次追踪中所有的span
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/data/spans/{rowKey}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取一条具体的span
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/data/events</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
Query String
</td>
<td>
JSON/XML
</td>
<td>
根据查询条件获取事件列表，比如某个app某个时间段内所有的事件
</td>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/data/events/{rowKey}</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
NA
</td>
<td>
JSON/XML
</td>
<td>
获取一条具体的事件
</td>
</tr>
</table>

<h4 id="toc_1.6.2.4">Report Api</h4>

<table>
<tr>
<th>
Api 地址
</th>
<th>
支持的方法
</th>
<th>
请求
</th>
<th>
返回
</th>
<th>
描述
</th>
</tr>
<tr>
<td colspan="5">
<em><strong>/logging/report/log</strong></em>
</td>
</tr>
<tr>
<td>
&nbsp;
</td>
<td>
GET
</td>
<td>
Query String
</td>
<td>
JSON/XML
</td>
<td>
根据查询条件获取日志统计信息，比如某个app某个时间段内日志每小时的分布情况
</td>
</tr>
</table>

<h3 id="toc_1.6.3">核心设计</h3>

<h4 id="toc_1.6.3.1">元数据获取</h4>
<ul>
<li>
department app server等元数据从第三方系统的获取

<li>
<em><strong>ToDo:</strong></em>  详细设计

</ul>

<h4 id="toc_1.6.3.2">查询日志数据</h4>
<ul>
<li>
查询参数的设计

<li>
<em><strong>ToDo:</strong></em>  详细设计

</ul>

<h4 id="toc_1.6.3.3">查询日志报表</h4>
<ul>
<li>
查询参数的设计

<li>
返回值的设计

<li>
<em><strong>ToDo:</strong></em>  详细设计

</ul>

<h2 id="toc_1.7">Log-Browser日志应用</h2>
<p>
Log-Browser主要是前端应用，以直觉导航的方式供用户查看日志数据。
</p>

<h3 id="toc_1.7.1">页面流设计</h3>

<p>
<img src="log-browser-page-flow.png" />
</p>

<p>
如上图页面流分为6张页面，也对应用户浏览日志的6个骤，从page 1到page 6.
</p>

<h4 id="toc_1.7.1.1">Page 1: 主页</h4>
<ol>
<li>
将作为Central Logging 2.0 web app的landing配置，各模块的入口。

<li>
比如浏览日志、搜索日志等

</ol>

<h4 id="toc_1.7.1.2">Page 2: 部门列表</h4>
<ol>
<li>
在page 1点击浏览日志进入

<li>
此页面将列出公司的所有部门

<li>
从Restful Api <code>/logging/meta/departments</code> 获取数据

</ol>

<h4 id="toc_1.7.1.3">Page 3: 应用列表</h4>
<ol>
<li>
在page 2点击某个部门进入

<li>
此页面将列出该部门的所有应用

<li>
从Restful Api <code>/logging/meta/apps</code> 获取数据

</ol>

<h4 id="toc_1.7.1.4">Page 4: 服务器列表</h4>
<ol>
<li>
在page 3点击某个应用进入

<li>
此页面将列出该应用的所有服务器

<li>
从Restful Api <code>/logging/meta/servers</code> 获取数据

</ol>

<h4 id="toc_1.7.1.5">Page 5: 服务器日志报表</h4>
<ol>
<li>
在page 4点击某台服务器进入

<li>
此页面将列出该服务器日志报表，提供两种方式：

<ol>
<li>
按天查看每小时的日志统计

<li>
按小时查看每五分钟的日志统计

</ol>
<li>
从Restful Api <code>/logging/report/log</code> 获取数据

</ol>

<h4 id="toc_1.7.1.6">Page 6: 日志列表</h4>
<ol>
<li>
在page 5做相点击进入进入

<li>
该页面可以查看一个小时内或五分钟内的日志详情

<li>
从Restful Api <code>/loggging/data/logs</code> 获取数据

</ol>

<h3 id="toc_1.7.2">页面流方案二</h3>
<p>
还有一种页面流方案，就是省略上一节的page 5, 直接从page 4到page 6.
而在page 4显示整个应用的日志统计信息。见下图。
</p>

<p>
其实两种方案并不冲突，可以并存！
</p>

<p>
<img src="log-browser-page-flow2.png" />
</p>

<h3 id="toc_1.7.3">页面逻辑设计</h3>
<p>
上面的页面，每个页面的逻辑结构是相似的，也应该持一致，这样可以保持项目维护。
</p>

<p>
<img src="log-browser-page-action.png" />
</p>

<p>
页面加载分为四个步骤：
</p>
<ol>
<li>
从Log-Browser的Server上load页面               

<li>
通过ajax从Restful Api加载相应的数据

<li>
根据数据渲染页面

<li>
为页面组件注册相关js事件

<li>
用户解发js事件，有可能跳转页面，也有可能从 2 重新执行

</ol>
  
<h3 id="toc_1.7.4">基础架构</h3>
<ul>
<li>
<em><strong>ToDo:</strong></em> 软件具体实现

</ul>

<h2 id="toc_1.8">其他模块关联更改</h2>

<h3 id="toc_1.8.1">HBase 日志查询优化</h3>
<p>
在Central Logging 2.0中存储在HBase中的日志，目前的方案是有所缺陷和性能瓶颈的。
</p>

<h4 id="toc_1.8.1.1">现有方案及问题</h4>
<p>
目前Log是通过HBaseWriter写表freeway.rawlog中的，而查询方案如下：
</p>

<p>
<img src="rawlog-old.png" />
</p>

<p>
日志查询实现总体分为两大步Scan和Filter,详细步骤如下：
</p>
<ol>
<li>
scan出100条记录，返回反序化成原始数据

<li>
逐条Filter,看是否满足查询条件，若满足就放入result待返回

<li>
查看result是否满足条数，满足返回

<li>
查看是否超时，超时返回，不超时执行1

</ol>

<p>
<strong>问题:</strong>
</p>
<ol>
<li>
使用逐条过滤，效率不高，容易超时

<li>
产生大量无效网络流量，使用客户端过滤, 每次都要取回原始log数据

</ol>

<h4 id="toc_1.8.1.2">优化方案</h4>
<p>
解决方案就是为rowlog表建立一张index表，查询时，先查index表，再查rawlog表
</p>

<p>
<img src="rawlog-new.png" />
</p>

<p>
新方案查询如下：
</p>
<ol>
<li>
根据条件去sacan rawlogindex表

<li>
最终生成一个包含rawlog rowkey的列表

<li>
根据rowkey列表，从rawlog表中get出所需的数据

<li>
放入result返回

</ol>

<h4 id="toc_1.8.1.3">rawlogindex表设计</h4>
<p>
新方案的好坏很大一部分取决于步骤一，步骤一的目标：
</p>
<ol>
<li>
更快

<li>
传输的数据更少

<li>
尽量在HBase端做过滤

</ol>

<p>
所以，根据常用查询条件，设计rawlogindex表如下：
<table>
<tr>
<th colspan="9">
rowkey
</th>
<th>
column family:rawlog
</th>
</tr>
<tr>
<td>
AppId
</td>
<td>
DC
</td>
<td>
Days
</td>
<td>
Seconds
</td>
<td>
HostName
</td>
<td>
IP
</td>
<td>
ThreadId
</td>
<td>
LogLevel
</td>
<td>
AddtionalInfo
</td>
<td rowspan="2">
RowLog RowKey
</td>
</tr>
<tr>
<td>
3B
</td>
<td>
1B
</td>
<td>
1B
</td>
<td>
3B
</td>
<td>
4B
</td>
<td>
1B
</td>
<td>
1B
</td>
<td>
1B
</td>
<td>
9B x 8 +7
</td>
</tr>
</table>
</p>

<p>
<strong>rowkey组成:</strong>
</p>

<ol>
<li>
<strong>AppId:</strong> 一数字,为了优化存储，足够散列，由原始appId计算获得: ???

<li>
<strong>DC:</strong> 数据中心，保留使用

<li>
<strong>Days:</strong> 距离1970/01/01 00:00的天数对30取模

<li>
<strong>Seconds:</strong> 距离0点的秒数，即Hour x 3600 + Seconds

<li>
<strong>HostName:</strong> 对HostName取4字节的Hash 

<li>
<strong>IP:</strong> 转换成数字

<li>
<strong>ThreadId:</strong> 数字

<li>
<strong>LogLevel:</strong> 数字 

<li>
<strong>AddtionalInfo:</strong>

<ol>
<li>
共8对，每对间使用|分隔

<li>
每对的key value使用:分隔

<li>
key和value都是长度4B, 是分别对原始key和vaue取Hash获得

</ol>
</ol>

<h4 id="toc_1.8.1.4">写实现</h4>
<ul>
<li>
HBaseWriter写log时需要同时写两张表

<li>
<em><strong>ToDo:详细设计</strong></em>

</ul>

<h4 id="toc_1.8.1.5">查询实现</h4>
<ul>
<li>
查询分两步，先查index,现取rawlog

<li>
<em><strong>ToDo:详细设计</strong></em>

</ul>

<h3 id="toc_1.8.2">HBase 日志统计</h3>
<p>
为了更好的记录应用的情况，我们以分钟为单位统计每个应用的日志情况，在一分钟内的:
</p>

<ul>
<li>
&lt;=Info level的日志数量

<li>
Warn level的日志数量

<li>
Error level的日志数量

</ul>

<h4 id="toc_1.8.2.1">表logstatistics设计</h4>
<table>
<tr>
<th colspan="7">
rowkey
</th>
<th colspan="3">
column family:log
</th>
</tr>
<tr>
<td>
AppId
</td>
<td>
DC
</td>
<td>
Days
</td>
<td>
Minutes
</td>
<td>
HostName
</td>
<td>
IP
</td>
<td>
ThreadId
</td>
<td rowspan="2">
infoCount
</td>
<td rowspan="2">
warnCount
</td>
<td rowspan="2">
errorCount
</td>
</tr>
<tr>
<td>
3B
</td>
<td>
1B
</td>
<td>
1B
</td>
<td>
3B
</td>
<td>
4B
</td>
<td>
1B
</td>
<td>
1B
</td>
</tr>
</table>

<h4 id="toc_1.8.2.2">HBaseWriter 日志统计模块</h4>
<ul>
<li>
<em><strong>ToDo:详细设计</strong></em>

</ul>

<h2 id="toc_1.9">部署架构</h2>
<h3 id="toc_1.9.1">域名</h3>
<h3 id="toc_1.9.2">部署图</h3>

</body>
</html>
