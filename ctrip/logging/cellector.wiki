%title Collector Code
=Collector Code=

*ThriftThreadedSelectorCollector :*
# main函数所在
# 实例Thrift None blocking tranport
# 实例Processor:ThriftCollectorLockFreeImpl 
# 启动SelectorServer

*TThreadedSelectorServerEx :*
# 扩展了TThreadedSelectorServer 
# 可以计算chunk的大小
*InvocationEx :*
# 计算chunk的大小

*ThriftCollectorLockFreeImpl:*
# 初始化HBase Client(Hbase存储了通用配置, agent config)
# 检查Habase中config表的存在
# 根据配置文件，初始化Queue
# 启动间隔从HBase中取agent config的task
# 注册shutdown hook: 关闭Hbase Client
# 注册shutdown hook: 关闭Queue
# 开启定时报告Collector状态的task

*FreewayConfigurationFactory :*
# 获取配置
# 配置文件：freeway-collector-conf.xml
# 使用了Hadoop的实例Configuration

*DaemonWatcher:*
# 用于退出系统，调用了System.exit(status)
# 它还继承了PidFile,使用一个file存储pid,但没发现使用的地方
 
*HostUtil:*
# fetch the hostName and hostName
# 获取第一份有效的ipv4
 
*StatReportingTask:*
# 每两钟收集一次collector状态信息

*SystemInfo:*
# 收集系统和java进程cpu内存使用情况
# 通过 Runtime 和 jezhumble

=java agent=
*MessageSender:*
# 正常发
# tryLater:
  # 两次随机睡5s
  # 一次随机睡30s
  # 两次随机睡5s
  # 一次随机睡60s 
# 异常:
  # 随机睡300s
  
*MetricsImpl:*
#  appid hostip外,最多四个tag



=Hbase Writer=
*throttleCount:*
# hbase client出错时，增加记数
# 连续出错越大，睡眠时间越长，但并未停止消费chunk

*LogEventProcesser:*
# AppIdSet
  # 启动时并未初始化
  # 而是不停的创建添加，使之这完美！
# log的很多column被禁掉了

=HDFS Writer=
*HDFSWriter:*
# 每小时检查一下，是否是新的一天，如果是就rotate
# 里面还有一个rotate策略，根据isNewFile
# ChunkProcessor还会间隔的往Collector里发States的chunk
# 从Collector里取chunk出现异常
  # 前三次睡100-300ms
  # 第四次睡2-5minutes  或 5-15分钟，断掉重连
  # 计数归0

MessageManager.startNewSender: isCoreThread?

