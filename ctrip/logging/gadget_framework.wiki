%title Gadget Framework

%toc

=Gadget Framework=
==概述 ==

目前logging2.0的collector使用了thrift进行了网络通信。实现上紧密耦合了thrift,以后扩展上很难，逻辑代码并没有和thrift的实现很好的隔离。
为了以后的协议扩展和协议替换或能够支持多种协议接口，并又很好的重用逻辑代码，达到解耦的目的，需要一个中间层框架。

借鉴现有的Struts2, Jersey, SpringMVC, Play等web框架的实现，他们都是基于HTTP协议，使用command模式处理请求的框架。但我们需要一个与协议无关，
通用的处理 request/response的框架。

{{gadget1.png}}

==设计 ==
{{gadget_design.png}}

===主要角色 ===
* *Application:* 容器类，管理框架内的所有类，交是请求的入口处
* *Request & Response:* 包装框架可以处理的请求，并返回的响应
* *Handler:* 最终用于处理Request的类，可以调用其他Logical Service
* *RequestFilter:* 在请求到达 Handler之前，可以通过一系列的Filter,进行一些预处理和统计类的工作。
* *ResponseFilter:* 在 Handler处理并返回Response后，可以通过一系列的Filter,进行一些再加工和统计类的工作。
* *ExceptionMapper:* 在处理过程中发生任何异常，可以定向到这里，进行统一处理，并返回相应的Response。

===工作过程 ===
# 构建Reqeust对象
# 传给Application
# Request会通过一系列的RequestFilter
# Handler接收请求处理
# Handler调用逻辑类处理
# Handler构建关返回Response
# Response通过一系列的ResponseFilter
# Application返回Reponse

==模块 ==
===主要类图 ===
{{gadget_classes.png}}

===一个Demo ===
{{{ class="brush:java"
    public void testGadget() throws Exception {
        GadgetConf gadgetConf = new GadgetConf();
        gadgetConf.setPackages("com.ctrip.freeway.gadget.a");
        gadgetConf.getTaskIntervals().put("gadget.task.TaskDemo.interval", 3);

        final Application application = new DefaultApplication(gadgetConf);

        int n = 10;
        Thread[] threads = new Thread[10];

        for (int i = 0; i < n; i++) {
            Thread thread = new Thread() {
                @Override
                public void run() {
                    for (int l = 0; l < 100; l++) {
                        Request<Integer> request = RequestBuilder.buildRequest();
                        request.setHeader(Headers.HOST.getCode(), "xingchaowang.ctrip.com");
                        request.setHeader(Headers.IP.getCode(), "192.168.1.1");
                        request.setHeader(Headers.COMMAND.getCode(), "add");

                        request.setBody(20);
                        System.out.println(Thread.currentThread().getId() + "\t:" + "request[" + 20 + "]");
                        
                        Response<Integer> response = application.handle(request);//处理请求
                        
                        System.out.println(Thread.currentThread().getId() + "\t:" + "response[" + response.getBody() + "]");
                    }
                }
            };
            thread.start();
            threads[i] = thread;
        }

        for (Thread thread : threads) {
            thread.join();
        }

        Thread.sleep(12000);
    }

  }}}

===构建Application ===
{{{ class="brush:java"
        GadgetConf gadgetConf = new GadgetConf();
        gadgetConf.setPackages("com.ctrip.freeway.gadget.a");
        
        Application application = new DefaultApplication(gadgetConf);
}}}
# 创建一个GadgetConf实例，传给它一个基包地址，可以是多个地址以逗号分隔
# AbtractApplication会扫描这个些包，把其中的RequestFilter, ResponseFilter, Handler, ExceptionMapper构建起来
# DefaultApplication负责具体的请求处理过程
# Application的方法 `Response handle(Request request)` 负责接收请求并返回响应

===消息体 ===
# Request和Response分别代表请求和响应
# 构成都分为Header和Body两部分
  {{{ class="brush:java"
    private List<Header> headers = Lists.newArrayList();
    private T body;
    }}}
# 应该设的Header
  {{{ class="brush:java"
    APPID("appId"),
    IP("ip"),
    HOST("host"),
    COMPRESS("compress"),
    SERIALIZE("serialize"),
    COMMAND("command");
    }}}
    

===过滤器 ===
# RequestFilter:
  {{{ class="brush:java"
    public interface RequestFilter {
        void filter(Request request);
    }
    }}}
# ResponseFilter:
  {{{ class="brush:java"
    public interface ResponseFilter {
        void filter(Response response);
    }
    }}}
# Demo，用于记录一个请求的处理时间：
  {{{ class="brush:java"
    public class AFilter implements RequestFilter, ResponseFilter {
        private Logger logger = LoggerFactory.getLogger(this.getClass());

        ThreadLocal<Long> start = new ThreadLocal<Long>();
        @Override
        public void filter(Request request) {
            logger.debug("request");
            start.set(System.currentTimeMillis());
        }

        @Override
        public void filter(Response response) {
            logger.debug("response");
            logger.info("Cost:" + (System.currentTimeMillis() - start.get()));
        }
    }
    }}}

===异常处理 ===
# 在处理请求的时候出现任何异常都可以由一个ExceptionMapper来处理
# ExceptionMapper

==计划任务 ==
框架中还内嵌了一个计划任务的框架，很方便的创建计划任务，并通过配置配置任务的执行策略

===创建一个Task ===
# Task接口
  {{{ class="brush:java"
    public interface Task extends Runnable{
    }
    }}}
# 只要实现这个接口就可以了
  {{{ class="brush:java"
    public class TaskDemo implements Task {
        private Logger logger = LoggerFactory.getLogger(TaskDemo.class);

        private int count = 0;

        @Override
        public void run() {
            logger.info("No. " + (++count));
        }
    }
    }}}

===配置一个Task ===
# 配置上面的Task, 每3s执行一次
  {{{ class="brush:java"
        GadgetConf gadgetConf = new GadgetConf();
        gadgetConf.setPackages("com.ctrip.freeway.gadget.a");
        gadgetConf.getTaskIntervals().put("gadget.task.TaskDemo.interval", 3);

        final Application application = new DefaultApplication(gadgetConf);
    }}}

==配置 ==
# GadgetConf类存储了framework的配置信息
# 目前的配置信息分部分
  {{{ class="brush:java"
    private String packages;
    private String objectFactory;
    private Map<String, Integer> taskIntervals = Maps.newConcurrentMap();
    }}}
   # packages是一个以逗号分隔的包列表，Application实例化时会扫描这些包，以此来构建自己
   # taskInterveals存放对每一个task的策略配置
   # objectFactory是一个类名，框架使用该类创建对象
 
==ObjectFactory==
# 这是一个接口，默认有一个实现，该实现负责框架管理对象的创建
  {{{ class="brush:java"
    public interface ObjectFactory {
        <T> T getInstance(Class<T> clazz) throws Exception;
    }
    }}}
# 该类是可以通过配置替换的，比如提供了一个GuiceObjectFactory, 和guice接合起来，实现依赖注入，简化编程，并提供了包含Logical Service在内的全局对象统一管理。

